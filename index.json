[{"categories":["tools"],"content":"花了几天时间将博客从 hexo 迁移到 Hugo，记录一下感受及过程。 博客有很长时间没有更新了，趁着时间充裕再次写起来。 之前就考虑更换 hexo，虽然主题和插件很丰富，但是安装起来还是不便，又需要 Node.js 环境，又需要安装一堆插件。 比较后决定使用 hugo，安装方便直接二进制文件即可使用，渲染速度更快，就是主题没有 hexo 丰富。 ","date":"2025-08-10","objectID":"/article/2025/08/10/hexo-to-hugo/:0:0","tags":["hugo","markdown"],"title":"Hexo 迁移到 Hugo","uri":"/article/2025/08/10/hexo-to-hugo/"},{"categories":["tools"],"content":"安装 可查看Hugo安装官方文档。 我是使用 Ubuntu 系统，建议直接使用二进制安装，还需要注意自已使用的主题支持版本是哪些。 注意 snap 安装时在使用 hugo mod 命令需要注意权限问题，否则会报错。 安装后检查版本，注意是否包含 extended： $ hugo version $ hugo v0.145.0-666444f0a52132f9fec9f71cf25b441cc6a4f355+extended linux/amd64 BuildDate=2025-02-26T15:41:25Z VendorInfo=gohugoio ","date":"2025-08-10","objectID":"/article/2025/08/10/hexo-to-hugo/:1:0","tags":["hugo","markdown"],"title":"Hexo 迁移到 Hugo","uri":"/article/2025/08/10/hexo-to-hugo/"},{"categories":["tools"],"content":"迁移 迁移一开始并不是很顺利，首先主题很多在首次测试时就渲染失败，感觉主题使用 submodule 引入比 hugo mod 引入更好控制。 然后文章属性需要根据选择的主题修改适配，该部分可以借助一下 AI 工具。 ","date":"2025-08-10","objectID":"/article/2025/08/10/hexo-to-hugo/:2:0","tags":["hugo","markdown"],"title":"Hexo 迁移到 Hugo","uri":"/article/2025/08/10/hexo-to-hugo/"},{"categories":["tools"],"content":"shortcode hugo 建议使用 shortcode 渲染内容，保持 markdown 的简洁。 如果加入其他自定义 html 格式，可以添加自己的 shortcode。 如我之前文章《Markdown 增强》中会使用到 html 原生语言。 在 hexo 中，我使用 {% raw %} 标签注释，在 hugo 中则可添加模板 layouts/shortcodes/html.html： {{ .Inner }} 然后文章需要原生 html 的地方，使用 {% html %} 标签： {{\u003c html \u003e}} ... {{\u003c /html \u003e}} ","date":"2025-08-10","objectID":"/article/2025/08/10/hexo-to-hugo/:2:1","tags":["hugo","markdown"],"title":"Hexo 迁移到 Hugo","uri":"/article/2025/08/10/hexo-to-hugo/"},{"categories":["tools"],"content":"使用 vscode 中可以添加一些任务脚本辅助： { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"serve\", \"type\": \"shell\", \"command\": \"hugo serve --disableFastRender\" }, { \"label\": \"production\", \"type\": \"shell\", \"command\": \"hugo serve -e production\" }, { \"label\": \"debug\", \"type\": \"shell\", \"command\": \"hugo server -D --disableFastRender\" }, { \"label\": \"new\", \"type\": \"shell\", \"command\": \"hugo new posts/draft/index.zh-cn.md\" } ] } ","date":"2025-08-10","objectID":"/article/2025/08/10/hexo-to-hugo/:3:0","tags":["hugo","markdown"],"title":"Hexo 迁移到 Hugo","uri":"/article/2025/08/10/hexo-to-hugo/"},{"categories":["tools"],"content":"VBox 镜像迁移 QEMU","date":"2020-09-17","objectID":"/article/2020/09/17/vbox-img-to-qemu/","tags":["vbox","qemu"],"title":"VBox 镜像迁移 QEMU","uri":"/article/2020/09/17/vbox-img-to-qemu/"},{"categories":["tools"],"content":"电脑重装不想再安装 vbox，试试 qume 能不能使用原来的镜像。 找到原来镜像路径，我的镜像文件名是 centos-disk001.vdi，将其转换为 img： qemu-img convert -f vdi -O raw centos-disk001.vdi centos.img 尝试使用 qemu 启动： qemu-system-x86_64 -m 2048 -boot d -enable-kvm -smp 3 -hda centos.img -net nic 启动会自动弹出 qemu 窗口，查看是否能正常登录。 修改镜像在终端中启动，先拷贝出镜像中内核，位置一般在 /boot 目录下： [root@localhost ~]# ls /boot/ config-3.10.0-1062.4.1.el7.x86_64 efi grub grub2 initramfs-0-rescue-64fdeb4a6b984cc8a60bbd21fea1cd3c.img initramfs-3.10.0-1062.4.1.el7.x86_64.img initramfs-3.10.0-1062.4.1.el7.x86_64kdump.img initrd-plymouth.img symvers-3.10.0-1062.4.1.el7.x86_64.gz System.map-3.10.0-1062.4.1.el7.x86_64 vmlinuz-0-rescue-64fdeb4a6b984cc8a60bbd21fea1cd3c vmlinuz-3.10.0-1062.4.1.el7.x86_64 我的拷贝出 vmlinuz-3.10.0-1062.4.1.el7.x86_64 和 initramfs-3.10.0-1062.4.1.el7.x86_64.img 即可， 然后查看镜像 root 位置，在启动按 e 可查看引导信息：root=/dev/mapper/centos-root， 修改启动为： qemu-system-x86_64 -kernel vmlinuz-3.10.0-1062.4.1.el7.x86_64 -initrd initramfs-3.10.0-1062.4.1.el7.x86_64.img -append \"root=/dev/mapper/centos-root console=ttyS0 selinux=0\" -m 2048 -enable-kvm -smp 3 -hda centos.img -nographic -net nic 修改网络1 最后启动脚本如下： #!/bin/bash # Source function library. if [[ $EUID -ne 0 ]]; then echo ONLY ROOT CAN ACCESS exit 1 fi function up_br0() { ifconfig enp0s25 down # 首先关闭宿主机网卡接口 brctl addbr br0 # 添加一座名为 br0 的网桥 brctl addif br0 enp0s25 # 在 br0 中添加一个接口 brctl stp br0 off # 如果只有一个网桥，则关闭生成树协议 brctl setfd br0 1 # 设置 br0 的转发延迟 brctl sethello br0 1 # 设置 br0 的 hello 时间 ifconfig br0 0.0.0.0 promisc up # 启用 br0 接口 ifconfig enp0s25 0.0.0.0 promisc up # 启用网卡接口 dhclient br0 # 从 dhcp 服务器获得 br0 的 IP 地址 dhclient enp0s25 } function up_tap0() { tunctl -t tap0 -u root # 创建一个 tap0 接口，只允许 root 用户访问 brctl addif br0 tap0 # 在虚拟网桥中增加一个 tap0 接口 ifconfig tap0 0.0.0.0 promisc up # 启用 tap0 接口 } function clear() { ifconfig tap0 down brctl delif br0 tap0 tunctl -d tap0 ifconfig enp0s25 down ifconfig br0 down brctl delif br0 enp0s25 brctl delbr br0 ifconfig enp0s25 up } trap clear EXIT INT TERM up_br0 up_tap0 qemu-system-x86_64 -kernel vmlinuz-3.10.0-1062.4.1.el7.x86_64 -initrd initramfs-3.10.0-1062.4.1.el7.x86_64.img -append \"root=/dev/mapper/centos-root console=ttyS0 selinux=0\" -m 2048 -enable-kvm -smp 3 -hda centos.img -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no PS：退出 console 使用快捷键 Ctrl+A 再按 X QEMU 网络配置 ↩︎ ","date":"2020-09-17","objectID":"/article/2020/09/17/vbox-img-to-qemu/:0:0","tags":["vbox","qemu"],"title":"VBox 镜像迁移 QEMU","uri":"/article/2020/09/17/vbox-img-to-qemu/"},{"categories":["development"],"content":"JUnit 测试一些特殊使用记录","date":"2020-09-15","objectID":"/article/2020/09/15/junit-test/","tags":["java","junit","test"],"title":"JUnit 测试之邪门歪道","uri":"/article/2020/09/15/junit-test/"},{"categories":["development"],"content":"Java 单元测试一般使用 JUnit，但是总有些接口测试不便，需要特殊操作，当然可能如下方法并不被提倡，只作不时之需。 ","date":"2020-09-15","objectID":"/article/2020/09/15/junit-test/:0:0","tags":["java","junit","test"],"title":"JUnit 测试之邪门歪道","uri":"/article/2020/09/15/junit-test/"},{"categories":["development"],"content":"生成临时测试文件 File f = null; try { // tmp- 开头后接随机数字的 txt 文件，文件位置在 test 文件下 f = File.createTempFile(\"tmp-\", \".txt\", new File(\"test\")); BufferedWriter out = new BufferedWriter(new FileWriter(f)); out.write(\"Hello World!\"); out.close(); } catch (IOException e) { e.printStackTrace(); } finally { // 退出时删除文件 f.deleteOnExit(); } ","date":"2020-09-15","objectID":"/article/2020/09/15/junit-test/:1:0","tags":["java","junit","test"],"title":"JUnit 测试之邪门歪道","uri":"/article/2020/09/15/junit-test/"},{"categories":["development"],"content":"Properties 设置 Properties props = new Properties(); props.setProperty(\"XXXX\", \"/xxx/xxx/xxx.properties\"); System.setProperties(props); ","date":"2020-09-15","objectID":"/article/2020/09/15/junit-test/:2:0","tags":["java","junit","test"],"title":"JUnit 测试之邪门歪道","uri":"/article/2020/09/15/junit-test/"},{"categories":["development"],"content":"解除保护重新加载 有时测试需要重新加载 static 方法，可使用反射办到，如下： // 需要测试或使用的类 ObjectXXX c = new ObjectXXX(); Method methods[] = ObjectXXX.class.getDeclaredMethods(); for(int i = 0; i \u003c methods.length; i++) { // 需要调用的方法名 XXX if (methods[i].getName().equals(\"XXX\")) { // 如果该方法是 private 或者 protected 无法调用，设置为 true 即可解除保护 methods[i].setAccessible(true); // 调用该方法 methods[i].invoke(c, args); } } ","date":"2020-09-15","objectID":"/article/2020/09/15/junit-test/:3:0","tags":["java","junit","test"],"title":"JUnit 测试之邪门歪道","uri":"/article/2020/09/15/junit-test/"},{"categories":["troubleshooting"],"content":"记一次 Java 错误查询","date":"2020-04-19","objectID":"/article/2020/04/19/too-many-open-files/","tags":["java"],"title":"Too Many Open files","uri":"/article/2020/04/19/too-many-open-files/"},{"categories":["troubleshooting"],"content":"最近发现了一个历史 bug，挺有意思，记录一下。 环境：JDK7 系统：CentOS 现象：长时间运行后程序无响应 开始我怀疑是不是哪里死锁了，找了一圈也没有发现问题； 后来再次出现该问题时尝试使用 jstack 查看当前状态，然而出现以下信息： Unable to open socket file: target process not responding or HotSpot VM not loaded The -F option can be used when the target process is not responding 再次加上 -F 参数： java.lang.RuntimeException: Unable to deduce type of thread from address 0x00007fb1f430f000 (expected type JavaThread, CompilerThread, ServiceThread, JvmtiAgentThread, or SurrogateLockerThread) at sun.jvm.hotspot.runtime.Threads.createJavaThreadWrapper(Threads.java:166) at sun.jvm.hotspot.runtime.Threads.first(Threads.java:150) at sun.jvm.hotspot.runtime.DeadlockDetector.createThreadTable(DeadlockDetector.java:149) at sun.jvm.hotspot.runtime.DeadlockDetector.print(DeadlockDetector.java:56) at sun.jvm.hotspot.runtime.DeadlockDetector.print(DeadlockDetector.java:39) at sun.jvm.hotspot.tools.StackTrace.run(StackTrace.java:62) at sun.jvm.hotspot.tools.StackTrace.run(StackTrace.java:45) at sun.jvm.hotspot.tools.JStack.run(JStack.java:66) at sun.jvm.hotspot.tools.Tool.startInternal(Tool.java:260) at sun.jvm.hotspot.tools.Tool.start(Tool.java:223) at sun.jvm.hotspot.tools.Tool.execute(Tool.java:118) at sun.jvm.hotspot.tools.JStack.main(JStack.java:92) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at sun.tools.jstack.JStack.runJStackTool(JStack.java:140) at sun.tools.jstack.JStack.main(JStack.java:106) ... 完全无法查看到任何有用的信息。 开始怀疑是不是有内存泄露，然而 JAVA 是存在自动回收机制的，这要排查哪里的问题似乎不太容易。 后来在 LOG 输出中发现了一条错误：Too Many Open files error，很多打开文件操作都出现了这个错误，那就是有文件没有正确关闭了？ 一般运行的程序都有一个 Max open files 的最大限制1： $ cat /proc/PID/limits Limit Soft Limit Hard Limit Units Max cpu time unlimited unlimited seconds Max file size unlimited unlimited bytes Max data size unlimited unlimited bytes Max stack size 8388608 unlimited bytes Max core file size 0 unlimited bytes Max resident set unlimited unlimited bytes Max processes 63177 63177 processes Max open files 8192 1048576 files Max locked memory 16777216 16777216 bytes Max address space unlimited unlimited bytes Max file locks unlimited unlimited locks Max pending signals 63177 63177 signals Max msgqueue size 819200 819200 bytes Max nice priority 0 0 Max realtime priority 0 0 Max realtime timeout unlimited unlimited us 当超出当前限制，程序将无法申请打开任何新的句柄。那么如何查看当前已经使用了多少资源呢？ $ ls -la /proc/PID/fd 不看不知道一看吓一跳，原来程序中有很多 socket 连接，后来发现其中网络部分有连接使用完没有正确 close，就是这样一个小疏忽，最终造成程序死机。 最后一个没有用到的，我现在怀疑 jstack 报错可能和这个也有关系，如果临时调整 Max open files 参数是不是可以解决这个报错呢？ 查找到可以使用以下命令动态调整进程限制文件数量： prlimit -nNUM -p PID 总结：程序稳定性测试时候也应该多多使用 jstack \u0026 limits，查看一下长时间运行后有没有不停增加的线程及文件，因为这种问题不是那么容易暴露的。 Resolve “Too Many Open files error” issues in WebSphere Application Server running on Linux ↩︎ ","date":"2020-04-19","objectID":"/article/2020/04/19/too-many-open-files/:0:0","tags":["java"],"title":"Too Many Open files","uri":"/article/2020/04/19/too-many-open-files/"},{"categories":["tools"],"content":"Docker 使用","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"Docker 前几年为了配置数据库接触过一次，仅限于 run \u0026 start 之类。 今天详细看看官方文档，记录一下。 ","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/:0:0","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"安装1 我使用的系统是 CentOS，内核版本 3.10.0-957.el7.x86_64： 卸载旧版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装存储库及依赖包 yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装最新版 Docker yum install docker-ce docker-ce-cli containerd.io 检查版本 docker --version 启动 systemctl start docker docker info ","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/:1:0","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"常用 列出镜像容器等 docker image ls docker container ls -a docker volume ls 这些信息也可以查看 /var/lib/docker 文件夹 删除 docker container rm [CONTAINER ID] 这类指令规律都是相似的 这里我遇到一个问题，ls 显示镜像，但是无法 rm，会提示 Error: No such image； 好像是之前残留的问题，如果没有重要的文件可以如下解决： systemctl stop docker rm -rf /var/lib/docker systemctl start docker 排错 有时需要查看 log 方便排错2 docker logs [OPTIONS] CONTAINER OPTIONS -f：跟踪日志输出 --since：显示某个开始时间的所有日志 -t：显示时间戳 --tail：仅列出最新 N 条容器日志 ","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/:2:0","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"bash 启动新系统容器并连接到当前 bash： ## docker run -it debian:stable /bin/bash root@xxxx:/# 退出重新连接容器： ## docker exec -it xxxx /bin/bash root@xxxx:/# ","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/:2:1","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"构建3 ","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/:3:0","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"Dockerfile 官网有完整的例子，使用 Dockerfile 构建一个自己的镜像，一般注意如下： 尽量使用别人已经构建好的镜像4 尽量减少层（layer），我如果理解没错，官方例子是七层 将容器中位置绑定到当前目录5 docker run -p 4000:80 --mount type=bind,source=\"$(pwd)\",target=/home/logs/ hello:v1 关于存储可查看 Manage data in Docker： Volumes：存储在 /var/lib/docker/volumes/ Bind mounts：可绑定本机 tmpfs mounts：仅存储在内存中 ","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/:3:1","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"docker-compose.yml 启动服务感觉比 run 更高级一层，可以执行更复杂的配置，比如定义 CPU 占用率等 ","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/:3:2","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"应用 ","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/:4:0","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"mysql 使用 docker 本地配置一个 mysql 数据库6： ## 拉取最新镜像 docker pull mariadb ## 拉取指定版本镜像 docker pull mariadb:x.x.x 数据库保存到本地，文件结构如下： test docker-compose.yml mysql ## docker-compose.yml version: '2' services: mysql: image: mariadb:x.x.x container_name: db-test volumes: - ./mysql:/var/lib/mysql ## 容器中数据保存在本地指定文件夹下 environment: - MYSQL_ROOT_PASSWORD=111111 ## 配置数据库密码 ports: - \"3306:3306\" ## 将容器端口引出，前者表示本机端口 在 test 文件夹下编译容器： docker-compose -f docker-compose.yml up 数据库导入： ## 从其他数据库导出全部数据 mysqldump -uroot -p --databases xxx \u003e /xxx/xxx/backup.sql ## 把文件考入到 docker 中 docker cp /xxx/xxx/backup.sql db-test:/backup.sql ## 进入 docker 导入数据 docker exec -it db-test bash mysql -uroot -p \u003c backup.sql Docker Engine ↩︎ Docker logs 命令 ↩︎ Dockerfile ↩︎ dockerhub ↩︎ Docker run 命令说明 ↩︎ Docker系列之实战：3.安装MariaDB ↩︎ ","date":"2019-08-14","objectID":"/article/2019/08/14/docker-apply/:4:1","tags":["docker"],"title":"Docker 使用","uri":"/article/2019/08/14/docker-apply/"},{"categories":["tools"],"content":"VSCode 使用","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["tools"],"content":"从 Sublime 投入 VSCode 怀抱。 自己一些常用插件配置。 linux 下在终端打开文件 code /xxx/xxx/xxx.xxx 屏蔽某些文件或文件夹 { // settings.json \"files.watcherExclude\": { \"**/vendor/**\": true }, \"files.exclude\": { \"bin\": true, \"pkg\": true } } 添加自定义环境变量 { // settings.json \"terminal.integrated.env.linux\": { // or osx/windows \"MY_ENV\": \"xxx\" }, } 以上设置好了重启 vscode 在终端中 echo $MY_ENV 就会看到设置的数据了 工作空间及任务 有时一个工程需要多个部分配合，但是又不想开很多个窗口，这时可以使用工作空间将其整合到一起。但是这时又有个问题是 task（任务）怎么统一使用一个呢，比如统一编译什么的，目前解决方法是再建立一个文件夹到工作空间，里面写脚本实现，大致如下： { // tasks.json \"version\": \"2.0.0\", \"linux\": { \"command\": \"/xxx/xxx/xxx\" // 实现脚本路径 }, \"tasks\": [ { \"label\": \"build\", // task 标签 \"type\": \"shell\", \"args\": [ \"build\" // 脚本参数 ], \"isBackground\": true }, { \"label\": \"clean\", \"type\": \"shell\", \"args\": [ \"clean\" ], \"isBackground\": true } ] } 脚本中各个工程路径可以从 xxx.code-workspace 工作空间配置中获取： function path() { echo `cat .vscode/workspace.code-workspace | grep $1 | awk '{print $2}' | sed 's/\\\"//g'` } MYPROJ=`path XXX` // 获得路径 ","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/:0:0","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["tools"],"content":"tools Settings Sync：同步备份插件及用户设置到 github，方便恢复 Chinese (Simplified) Language Pack for Visual Studio Code：对于英语渣来说还是很有必要的 TODO Highlight：代码中 TODO 会被高亮 vscode-icons：好看 ","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/:1:0","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["tools"],"content":"git 一般直接使用自带的或者命令行，感觉还可以，挺方便的。 GitLens：可以直接看到每行代码是什么时候谁写的（公开处刑） ","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/:1:1","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["tools"],"content":"markdown Markdown All in One Markdown Preview Enhanced：预览结果 ","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/:1:2","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["tools"],"content":"go 现在我的 golang 基本都是在 VSCode 上开发了。 Go：需要下载一堆插件准备好 VPN 吧 在 linux 中交叉编译 wins env GOOS=windows GOARCH=amd64 go get -u -v github.com/xxx/xxx 在 wins 中交叉编译 linux CGO_ENABLED=0 // 坏境变量中配置 GOOS=linux GOARCH=amd64 工程单独配置 settings.json { \"go.goroot\": \"c:\\\\Go\", \"go.gopath\": \"d:\\\\GitLib\\\\Golang;${workspaceRoot}\", // 多个路径 \"go.toolsEnvVars\": { \"GO111MODULE\": \"on\", // 设置 go 环境变量 \"CGO_ENABLED\": 0, \"GOOS\": \"linux\", \"GOARCH\": \"amd64\", }, \"files.exclude\": { \"**/vendor/**\": true }, \"files.watcherExclude\": { \"**/vendor/**\": true } } ","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/:2:0","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["tools"],"content":"C 还没有真的在这上编译 C 代码，不过之前都是使用 Sublime，这个应该更好用的吧。 C/C++ ","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/:3:0","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["tools"],"content":"java 这部分也没有怎么使用过，网上有详细的说明文档，只要打开一个 java 文件，会自动建议你安装一些插件。 Language support for Java ™ for Visual Studio Code Java Extension Pack Java Dependency Viewer Debugger for Java Java Test Runner Maven for Java 新建一个工程：Ctrl+P 打开控制台，输入 \u003eCrea，选择 Java: Create Java Project。 我尝试的时候例子怎么都无法运行，报「找不到或无法加载主类 App」，后来发现是因为路径问题，这个文件我在虚拟机共享文件夹下建的，路径包括 \\\\192.168.xx.xx\\...。 添加 lib：.classpath 中添加 \u003cclasspathentry kind=\"lib\" path=\"xxx/xxx.jar\"/\u003e 只能一个包一个包添加 设置不同的版本：插件目前只能在 JDK11 以上才能运行，那么老的工程怎么使用呢？ 在 settings.json 中设置如下： \"java.home\": \"/xxx/jdk-14\", \"java.configuration.runtimes\": [ { \"default\": true, \"name\": \"JavaSE-1.7\", \"path\": \"/xxx/jdk1.7.0_80/\", }, { \"name\": \"JavaSE-1.8\", \"path\": \"/xxx/jdk1.8.0/\", }, ], 工程中指定某个版本 JDK，在 .classpath 中添加 \u003cclasspathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.x\"/\u003e 在使用 1.7 时发现一个报错： Access restriction: The type 'HttpHandler' is not API (restriction on required library '/opt/local/java/jdk1.7.0_80/jre/lib/rt.jar') 解决方法修改 .classpath 如下： \u003cclasspathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7\"\u003e \u003caccessrules\u003e \u003caccessrule kind=\"accessible\" pattern=\"com/sun/net/**\"/\u003e \u003c/accessrules\u003e \u003c/classpathentry\u003e 添加 Junit Lib：.classpath 中添加 \u003cclasspathentry kind=\"con\" path=\"org.eclipse.jdt.junit.JUNIT_CONTAINER/4\"/\u003e Junit 运行版本报错的话，需要修改 runtimes 配置 default 版本与当前一致即可 ","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/:4:0","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["tools"],"content":"maven 使用 maven 新建一个工程： 先设置工具路径 \"maven.executable.path\": \"C:\\\\xxx\\\\mvn\" 打开控制台输入 \u003emaven，选择 Generate from Maven Archetype，选择 maven-archetype-quickstart，根据提示输入就行，其中命名规范网上整理的很多1。 maven 添加自己的 package 方法： \u003cbuild\u003e \u003cpluginManagement\u003e\u003c!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --\u003e \u003cplugins\u003e ... \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-shade-plugin\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/plugin\u003e ... \u003c/plugins\u003e \u003c/pluginManagement\u003e \u003c!-- plugins section : plugins that are invoked when building the project --\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-shade-plugin\u003c/artifactId\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003eapp\u003c/id\u003e \u003c!-- 多个包 ID --\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003eshade\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003coutputFile\u003etarget/${project.artifactId}-app-${project.version}.jar\u003c/outputFile\u003e \u003c!-- 打包自定义名字 --\u003e \u003cminimizeJar\u003etrue\u003c/minimizeJar\u003e \u003c!-- 只打使用的类，未测试过，在 1.7 上没法使用 --\u003e \u003cfilters\u003e \u003cfilter\u003e \u003cartifact\u003e${project.groupId}:${project.artifactId}\u003c/artifact\u003e \u003c!-- 过滤自己的代码 --\u003e \u003cincludes\u003e \u003cinclude\u003ecom/wishlily/helloworld/App.**\u003c/include\u003e \u003c/includes\u003e \u003c/filter\u003e \u003cfilter\u003e \u003cartifact\u003eio.*:*\u003c/artifact\u003e \u003c!-- 打包其他库的选择器 --\u003e \u003cexcludes\u003e \u003cexclude\u003e**\u003c/exclude\u003e \u003c/excludes\u003e \u003c/filter\u003e \u003c/filters\u003e \u003ctransformers\u003e \u003ctransformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"\u003e \u003cmainClass\u003ehelloworld.App\u003c/mainClass\u003e \u003c!-- jar main 入口 --\u003e \u003c/transformer\u003e \u003c/transformers\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c!-- 还可以添加另一个 jar 包，同上 --\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 开始怎么在 pluginManagement 中添加 maven-shade-plugin 插件都不能起作用2。 maven 添加本地库3： \u003cdependency\u003e \u003cgroupId\u003eanything\u003c/groupId\u003e \u003cartifactId\u003eanything\u003c/artifactId\u003e \u003cversion\u003eanything\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003c!-- 参数为 test 则表示只有测试代码使用 --\u003e \u003csystemPath\u003e${basedir}/lib/xxx.jar\u003c/systemPath\u003e \u003c!-- jar 所在路径，basedir 即 pom.xml 所在目录 --\u003e \u003c/dependency\u003e ","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/:4:1","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["tools"],"content":"gradle build.gradle 自定义 url repositories { maven { url \"${nexusUrl}/repository/xxx/\" } } nexusUrl 可以在 gradle.properties 中定义4： nexusUrl=http://localhost:8081/nexus nexusUsername=admin nexusPassword=admin123 Access restriction: The type 'XXX' is not API (/xxx/jre/lib/xx.jar) 如果报类似以上错误，可以在 build.gradle 添加以下插件： import org.gradle.plugins.ide.eclipse.model.AccessRule apply plugin: 'eclipse' eclipse { classpath { file { whenMerged { def jre = entries.find { it.path.contains 'org.eclipse.jdt.launching.JRE_CONTAINER' } jre.accessRules.add(new AccessRule('0', 'ssl/**')) // 忽略部分路径 jre.accessRules.add(new AccessRule('0', 'com/sun/net/ssl/internal/ssl/**')) } } } } Maven命名规范收集 ↩︎ pluginManagement interferes with shade plugin ↩︎ Local_Jar_Dependency_With_Maven ↩︎ Gradle ↩︎ ","date":"2019-06-13","objectID":"/article/2019/06/13/vscode/:4:2","tags":["ide"],"title":"VSCode","uri":"/article/2019/06/13/vscode/"},{"categories":["network"],"content":"最近使用了一下 grpc 通信，现在整理一下，防止遗忘。 ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:0:0","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"安装 grpc 可以支持不同的语言，详细可查看 github。 这次我主要使用的是 go 和 java， golang 因为墙的关系有几个包需要找镜像下载1 git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text git clone https://github.com/golang/sys.git $GOPATH/src/golang.org/x/sys go get -u github.com/golang/protobuf/{proto,protoc-gen-go} git clone https://github.com/google/go-genproto.git $GOPATH/src/google.golang.org/genproto cd $GOPATH/src/ go install google.golang.org/grpc 我看官方也详细写了使用 go mod 的安装方法。 ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:1:0","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"protoc 这是一个通过 proto 文件，自动生成不同语言代码的工具。 github 上可以直接下载 release，地址：https://github.com/protocolbuffers/protobuf/releases。 比较省事的就是下载编译好的程序，比如我系统是 linux 64，就下载 protoc-x.x.x-linux-x86_64.zip，直接解压放到 PATH 下就行，protoc --veriosn 查看版本。 ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:1:1","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"protoc-gen-go 配合 protoc goalng 使用的插件 go get -u github.com/golang/protobuf/{proto,protoc-gen-go} 使用时注意 protoc-gen-go 必须在系统 PATH 中 export PATH=$PATH:$GOPATH/bin 运行以下命令可以自动生成 go 文件 protoc --go_out=plugins=grpc:. *.proto ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:1:2","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"protoc-gen-grpc-java 官方提供的 java 插件，安装下载地址 https://github.com/grpc/grpc-java/tree/master/compiler 貌似系统 java 1.7 无法编译，应该需要更高的版本，或者下载已经编译好的工具，如 1.19 运行以下命令自动生成 java 文件 protoc --java_out=. *.proto protoc --plugin=protoc-gen-grpc-java=/xxx/xxx/protoc-gen-grpc-java --grpc-java_out=. *.proto 路径根据实际情况修改，java 至少需要 2 个文件 ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:1:3","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"proto 官方都有给简易例子，以下添加一些说明： syntax = \"proto3\"; option java_multiple_files = false; // java 文件是否生成多个文件，我直接选择否方便 git 操作 option java_package = \"com.wishlily.helloworld\"; // java 路径 option java_outer_classname = \"HelloWorldProto\"; // java 类名 package grpc; // golang 包名 // 通信接口 service Greeter { rpc SayHello(Hello) returns (Null) {} // 客户端给服务器信息 rpc SayBye(Null) returns (stream Bye) {} // 可用作服务器回调信息 } message Null {} // 即便传输为空也需要一个构造，或者引入官方包中的 google.protobuf.Empty message Hello { string name = 1; string msg = 2; int64 num = 3; } message Bye { enum Number { ONE = 0; TWO = 1; } Number num = 1; string msg = 2; } ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:2:0","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"go 根据官方例子修改如下： ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:3:0","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"server package main import ( \"context\" \"fmt\" \"net\" \"time\" pb \"sayhi/grpc\" // protoc-gen-go 生成文件包 \"google.golang.org/grpc\" ) type server struct { hi bool number int64 name string msg string } // 客户端 -\u003e 服务器 func (s *server) SayHello(ctx context.Context, in *pb.Hello) (*pb.Null, error) { reply := \u0026pb.Null{} s.number = in.GetNum() s.name = in.GetName() s.msg = in.GetMsg() fmt.Printf(\"%d: %s Say %s\\n\", s.number, s.name, s.msg) s.hi = true return reply, nil } // 服务器 -\u003e 客户端 func (s *server) SayBye(in *pb.Null, stream pb.Greeter_SayByeServer) error { for { // 此处不退出，会一直在该线路上发送，哪怕连接已断，一定要判断 Send 结果 if s.hi { bye := \u0026pb.Bye{ Msg: \"Receive: \" + s.msg, } if (s.number % 2) == 0 { bye.Num = pb.Bye_ONE } else { bye.Num = pb.Bye_TWO } if err := stream.Send(bye); err != nil { // 服务器主动发起消息 return err // Disconnect } s.hi = false } else { time.Sleep(100 * time.Millisecond) } } } func main() { lis, err := net.Listen(\"tcp\", \"localhost:10086\") if err != nil { panic(err) } s := grpc.NewServer() pb.RegisterGreeterServer(s, new(server)) fmt.Println(\"Server start ...\") if err := s.Serve(lis); err != nil { panic(err) } } 开始接触 grpc 时一直想不明白，服务器怎么主动发起消息，后来明白其实就使用 stream，单方向就一直保持这个 stream 不关闭就行，当然这个连接还是要 client 先发起才行。 ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:3:1","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"client func main() { wait := make(chan int, 1) conn, err := grpc.Dial(\"localhost:10086\", grpc.WithInsecure()) if err != nil { panic(err) } defer conn.Close() c := pb.NewGreeterClient(conn) name := \"Robyn\" if len(os.Args) \u003e 1 { name = os.Args[1] } msg := \"Hello\" if len(os.Args) \u003e 2 { msg = os.Args[2] } num := int64(120) if len(os.Args) \u003e 3 { n, _ := strconv.Atoi(os.Args[3]) num = int64(n) } ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() _, err = c.SayHello(ctx, \u0026pb.Hello{Name: name, Msg: msg, Num: num}) if err != nil { panic(err) } fmt.Printf(\"%d: %s Say %s\\n\", num, name, msg) go func() { ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() stream, err := c.SayBye(ctx, \u0026pb.Null{}) if err != nil { panic(err) } for { bye, err := stream.Recv() if err == io.EOF { break } if err != nil { panic(err) } fmt.Printf(\"Say Bye %v %v\\n\", bye.GetNum(), bye.GetMsg()) break } wait \u003c- 0 }() \u003c-wait } ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:3:2","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"demo 测试结果如下： client [root@localhost client]## go run main.go Say Bye ONE:Receive: Hello 120: Robyn Say Hello [root@localhost client]## go run main.go Emily Hi 23 Say Bye TWO Receive: Hi 23: Emily Say Hi server [root@localhost server]## go run main.go Server start ... 120: Robyn Say Hello 23: Emily Say Hi ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:3:3","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"java 首先介绍打包方式：一种是使用 maven，另一种是使用 ant。 maven 这部分根据官方例子摘抄 \u003cproperties\u003e ... \u003cgrpc.version\u003e1.19.0\u003c/grpc.version\u003e \u003c/properties\u003e \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-bom\u003c/artifactId\u003e \u003cversion\u003e${grpc.version}\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencyManagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-netty-shaded\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-protobuf\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.grpc\u003c/groupId\u003e \u003cartifactId\u003egrpc-stub\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ant 就需要提前下载好 jar 包，将这些一起打包到你的包里： \u003ctarget name=\"client\" depends=\"compile\"\u003e \u003cmkdir dir=\"${prepjar}\" /\u003e \u003ccopy todir=\"${prepjar}\"\u003e \u003cfileset dir=\"${classes}\"/\u003e \u003c/copy\u003e \u003cjar jarfile=\"${clientjarfilename}\" basedir=\"${prepjar}\"\u003e \u003cmanifest\u003e \u003cattribute name=\"Main-Class\" value=\"com.xxx.MainClass\" /\u003e \u003c/manifest\u003e \u003cexclude name=\"**/xxx/**\"/\u003e \u003czipgroupfileset dir=\"${grpc}\" includes=\"**/*.jar\" /\u003e \u003c!-- 主要这句拷贝路径下所有 jar --\u003e \u003c/jar\u003e \u003cdelete dir=\"${prepjar}\" /\u003e \u003c/target\u003e ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:4:0","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"server 服务器首先使用 protoc 工具生成两个文件：GreeterGrpc.java \u0026 HelloWorldProto.java。 public class Server { private io.grpc.Server server; private void start() throws IOException { int port = 10086; server = ServerBuilder.forPort(port).addService(new GreeterImpl()).build().start(); System.out.println(\"Server started, listening on 10086\"); Runtime.getRuntime().addShutdownHook(new Thread() { @Override public void run() { // Use stderr here since the logger may have been reset by its JVM shutdown // hook. System.err.println(\"*** shutting down gRPC server since JVM is shutting down\"); Server.this.stop(); System.err.println(\"*** server shut down\"); } }); } private void stop() { if (server != null) { server.shutdown(); } } private void blockUntilShutdown() throws InterruptedException { if (server != null) { server.awaitTermination(); } } static class GreeterImpl extends GreeterImplBase { private boolean sayHi = false; private Bye bye; public void sayHello(Hello req, StreamObserver\u003cNull\u003e responseObserver) { Null reply = Null.newBuilder().build(); Number num = Number.ONE; if (req.getNum() % 2 == 1) { num = Number.TWO; } String name = req.getName(); String msg = req.getMsg(); System.out.printf(\"%d: %s Say %s\\n\", req.getNum(), name, msg); bye = Bye.newBuilder().setNum(num).setMsg(\"Get: \" + msg).build(); responseObserver.onNext(reply); responseObserver.onCompleted(); sayHi = true; } public void sayBye(Null req, StreamObserver\u003cBye\u003e responseObserver) { while (true) { if (sayHi) { sayHi = false; System.out.printf(\"%s Bye %s\\n\", bye.getNum(), bye.getMsg()); try { responseObserver.onNext(bye); } catch (StatusRuntimeException e) { // 是 grpc 出现错误时抛出异常 System.out.println(e.toString()); responseObserver.onError(e); // 测试中如果没有 onError | onCompleted，则下一次连接会出现问题 break; } } else { try { Thread.sleep(1000); } catch (InterruptedException e) { } } } } } public static void main(String[] args) throws IOException, InterruptedException { final Server server = new Server(); server.start(); server.blockUntilShutdown(); } } ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:4:1","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"client public class Client { private final ManagedChannel channel; private final GreeterGrpc.GreeterBlockingStub blockingStub; private ByeListenThread byeListenThread; /** Construct client for accessing RouteGuide server at {@code host:port}. */ public Client(String host, int port) { this(ManagedChannelBuilder.forAddress(host, port).usePlaintext()); } /** * Construct client for accessing RouteGuide server using the existing channel. */ public Client(ManagedChannelBuilder\u003c?\u003e channelBuilder) { channel = channelBuilder.build(); blockingStub = GreeterGrpc.newBlockingStub(channel); byeListenThread = new ByeListenThread(); byeListenThread.setName(\"Client_ByeListenThread\"); byeListenThread.setDaemon(true); byeListenThread.start(); } public void shutdown() throws InterruptedException { channel.shutdown().awaitTermination(5, TimeUnit.SECONDS); byeListenThread.cancel(); } public void sayHello(String name, String msg, int num) { HelloWorldProto.Hello request = HelloWorldProto.Hello.newBuilder().setName(name).setMsg(msg).setNum(num) .build(); blockingStub.sayHello(request); System.out.printf(\"%d: %s Say %s\\n\", num, name, msg); } private class ByeListenThread extends Thread { private volatile boolean isAlive = false; HelloWorldProto.Null request = HelloWorldProto.Null.newBuilder().build(); public void run() { Iterator\u003cHelloWorldProto.Bye\u003e bye; while (isAlive) { bye = blockingStub.sayBye(request); while (bye.hasNext()) { // block HelloWorldProto.Bye data = bye.next(); // if data have ptr part, hasXXX check System.out.printf(\"Bye %s: %s\\n\", data.getNum(), data.getMsg()); } } } public synchronized void start() { isAlive = true; super.start(); } public synchronized void cancel() { isAlive = false; } } public static void main(String[] args) throws IOException, InterruptedException { Client c = new Client(\"127.0.0.1\", 10086); String name = \"Java\"; if (args.length \u003e 0) { name = args[0]; } String msg = \"hello\"; if (args.length \u003e 1) { msg = args[1]; } int num = 2046; if (args.length \u003e 2) { num = Integer.parseInt(args[2]); } c.sayHello(name, msg, num); // wait System.out.println(\"wait ...\"); InputStreamReader is_reader = new InputStreamReader(System.in); String str = new BufferedReader(is_reader).readLine(); c.shutdown(); } } ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:4:2","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["network"],"content":"demo 和 golang 一样而且可以交叉测试，不过 go client \u0026 java server 会有超时错误，没有详细查看。 golang安装gRpc ↩︎ ","date":"2019-06-09","objectID":"/article/2019/06/09/grpc/:4:3","tags":["grpc","go","java"],"title":"grpc","uri":"/article/2019/06/09/grpc/"},{"categories":["development"],"content":"react 组件通信一些心得记录","date":"2018-09-29","objectID":"/article/2018/09/29/react-component-communication/","tags":["react","web"],"title":"react 组件通信","uri":"/article/2018/09/29/react-component-communication/"},{"categories":["development"],"content":"react 使用一些心得记录。 ","date":"2018-09-29","objectID":"/article/2018/09/29/react-component-communication/:0:0","tags":["react","web"],"title":"react 组件通信","uri":"/article/2018/09/29/react-component-communication/"},{"categories":["development"],"content":"父子组件 父子之间通信主要通过 this.props。 ","date":"2018-09-29","objectID":"/article/2018/09/29/react-component-communication/:1:0","tags":["react","web"],"title":"react 组件通信","uri":"/article/2018/09/29/react-component-communication/"},{"categories":["development"],"content":"父-\u003e子 通过属性传入，传入如果是变量，当父值改变时子组件值也会改变。 以下将 Father 中 data 传入到 Son 中。 Son： class Son extends React.Component { state = { data: 'son', } // 父传来值改变 componentWillReceiveProps(nextProps) { // 父值改变 this.props.data if (nextProps.data \u0026\u0026 nextProps.data !== this.state.data) { this.setState({ data: nextProps.data }); } } render() { return ( \u003ca\u003e {this.props.data} \u003c/a\u003e ); } } export default Son; Father： class Father extends React.Component { state = { data: 'father', } render() { return ( \u003cSon data = {this.state.data} /\u003e ); } } ","date":"2018-09-29","objectID":"/article/2018/09/29/react-component-communication/:1:1","tags":["react","web"],"title":"react 组件通信","uri":"/article/2018/09/29/react-component-communication/"},{"categories":["development"],"content":"子-\u003e父 我感觉这个类似于函数回调，值传递需要借助这个回调函数。 还是举个例子，Son 中按钮按下动作传递给 Father。 Son： class Son extends React.Component { state { data: 'son', } onClick = () =\u003e { // 回调函数 if (this.props.onClick) this.props.onClick(this.state.data); } render() { return ( \u003cButton onClick={this.onClick}\u003ebutton\u003c/Button\u003e ); } } export default Son; Father： class Father extends React.Component { onClick = (value) =\u003e { console.log(\"son -\u003e\", value) } render() { return ( \u003cSon onClick = {this.onClick} /\u003e ); } } ","date":"2018-09-29","objectID":"/article/2018/09/29/react-component-communication/:1:2","tags":["react","web"],"title":"react 组件通信","uri":"/article/2018/09/29/react-component-communication/"},{"categories":["wireless"],"content":"RFID：ISO14443A","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"这是篇几年前总结的文档，现在重新整理一下。 首先建议看下《看得懂的 RFID 原理》这篇文章，当初找了不少资料就这篇让我明白了些 RFID 是怎么通信的。 ISO14443A 是常见的协议标准，大致如下： 载波频率 f：13.56MHz 数据传输率：13.56MHz/128 = 106Kbit/s 普通卡 PICC UID： 4 个字节 32 位数据 7 个字节 10 个字节 各部分协议内容： ISO/IEC 14443-1 制定了 PICC 的物理特性 ISO/IEC 14443-2 制定了射频功率及信号界面特性 ISO/IEC 14443-3 PICC 初始化和防冲突机制 ISO/IEC 14443-4 有关交易的协定 以下通过读卡器读卡来理解该协议，其中缩写表示如下： PICC：普通卡（M1 卡） PCD：读卡器（PN512） ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:0:0","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"选卡 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:1:0","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"PICC -\u003e Power Off PICC 静止状态周围没有可激活的 PCD 有效场 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:1:1","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"PICC -\u003e Idle PICC 进入 PCD 有效场，进入 Idle 状态（t\u003c=5ms），Idle 态可接受命令 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:1:2","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"REQA \u003c- PCD PCD 发送 REQA，检测是否有 PICC，0x26 7-bit 数据 Ps：两个连续 REQA 间隔 7000 / f （\u003e 0.516ms） //\u003e Mifare Request: SR 0A 80 // flush FIFO SR 09 26 // FIFO - Request code SR 0D 87 // BitframingReg - StartSend, TxLastBits PN512 简单测试用例脚本 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:1:3","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"PICC -\u003e ATQA PICC 向 PCD 发送自身信息 其中 b7b8 可以知道该卡 UID 字节数，一般定义如下： b5-b1 一般只有 1bit 为 1，如果有 2bit 为 1 则冲突了 //\u003e Response ATQ: GR 06 // Read ErrReg RE 0A 02 // Read FIFOLevel GR 09 // ATQ LSB // data=04 GR 09 // ATQ MSB // data=00 -\u003e Mifare Plus PCD 读到的数据是 0x0004，通过芯片官方文档（见下）可知该卡是 Mifare Plus 4 Byte UID 型号 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:1:4","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"Anticollision \u003c- PCD 防冲突没有实践过，所以可能理解有误。 下图是防冲突流程图： 由上图可以看出 PCD 发送的命令有 SEL NVB UID CLn 等部分组成： SEL：Select code 值可能是 0x93 0x95 0x97，表示不同的冲突阶段 防冲突等级区分如下（感觉和 UID 大小有关）： NVB：Number of Valid Bits 冲突发生的位置（第几个字节第几个位置） 官方文档有个防冲突例子，感觉还挺清楚的： 我的理解 PCD 防冲突检测第一阶段,要求所有 PICC 返回自己的 UID， 读卡器发送：0x93 0x20， 当冲突发生时，PCD 接收不完整的 UID，截止在冲突处（不是很明白 PCD 怎么知道冲突了？）， 下次 PCD 发送收到不完整 UID，PICC 接着响应直到没有冲突。 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:1:5","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"PICC -\u003e UID PICC 返回自己的 UID（记不清 PCD 是不是要先发送 0x93 0x20 了） UID 格式如下： //\u003e Response SNR: GR 06 // Read ErrReg RE 0A 05 // Read FIFOLevel GR 09 // Read SNR 0 // data=7A GR 09 // Read SNR 1 // data=4E GR 09 // Read SNR 2 // data=39 GR 09 // Read SNR 3 // data=48 GR 09 // Read SNR 4 (check byte) // data=45 BCC 为校验码，所以上面例子卡的 UID = 7A4E3948 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:1:6","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"SEL \u003c- PCD PCD 选择一张卡，发送 0x93 0x70 UID BCC CRC 有的芯片设置需要打开 CRC 校验 //\u003e Mifare Select: SR 0a 80 // flush FIFO SR 12 80 // TxMode: activate CRC SR 13 80 // RxMode: activate CRC SR 09 93 // fast activation of Mifare SR 09 70 // NVB byte SR 09 7A // Write SNR 0 SR 09 4E // Write SNR 1 SR 09 39 // Write SNR 2 SR 09 48 // Write SNR 3 SR 09 45 // Write SNR 4 (check byte) SR 0d 80 // BitframingReg - StartSend, TxLastBits ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:1:7","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"PICC -\u003e SAK PICC 确认 PCD 的选择 回复格式：SAK + CRC16 (2-byte) //\u003e Response SAK: GR 06 // Read ErrReg RE 0A 01 // Read FIFOLevel GR 09 // Read SAK // data=08 Mifare Classic 1K 例子中 SAK 回复 0x08，查看芯片手册为 Mifare Classic 1K 卡 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:1:8","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"读写 EEPROM ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:2:0","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"Mifare1 Card Mifare 1 卡片采用 EEPROM 作为存储介质，容量为 1K × 8 位 ，分为 16 个扇区（015），每个扇区有 4 个块（03），每块有 16 字节。一个扇区共 16Byte × 4 = 64Byte。扇区的第四块称作尾块，包含了该扇区的密码 A（6个字节）、存取控制（4个字节）、密码 B（6个字节），是控制块。其余三块是数据块。 扇区 0 的块 0 固化了厂商代码信息，不可改写。 其中： 第 0~4 字节为卡片的序列号 第 5 字节为序列号的校验码 第 6 字节为卡片的容量「SIZE」 第 7，8 字节为卡片的类型号（Tagtype） 其他字节由厂商另加定义 如下图所示： Control blocks 即每个扇区最后一块 存储格式如下： KeyA/B: 读取时返回 0（对 Key 的一种保护吧，默认 Key 一般是 0xFFFFFFFFFFFF），KeyB 不用可做数据字节( 9 字节亦然) Access Bit: 控制位，表示扇区各块属性 Byte9：没有实际意义，可当作数据块 控制块读写权限表如下： 图中灰色区域 keyB 可以当作数据区使用 修改 access bit 后最好重新认证一下 Data blocks 数据块，一般分两类： read/write blocks 一般用在非接触门禁管理，好像没有特殊格式要求 value blocks 其实应该是 read/write blocks 的特殊类型，一般用在电子钱包，有增值/减值（单独操作命令） 存储格式如下图： 可操作命令包括 read，write，increment（增值），decrement（减值），restore（恢复），transfer（转移） Vaule 值需要先按照上述格式 write 到存储数据，才能使用增减值等特殊指令操作 Adr 是进行备份管理时，用于保存块地址，只能通过 write 命令更改 数据块操作权限表如下： 在用于非充值卡的一种情况（001）下，只能够读和减值 在另一种情况（110）下，可以用 keyB 充值 终极权限下（111）扇区再也不能修改，keyA/B 需要保管好 Command M1 卡控制命令，上面都有提到，具体列表如下： ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:2:1","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"Authentication M1 卡手册中认证需要如下过程： 命令表示如下： 不过这部分其实还是要看读卡器怎么设置，PN512 手册里面要求如下： 即在 FIFO 写入 60/61 + addr + keyA/B(6byte) + UID(4byte) + CRC 判断认证结果： 成功：Status2 Reg[3]=1 失败：Status2 Reg[3]=0 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:2:2","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"Read 时序图： PN512： 发送：30 + addr + CRC 接收：data(16byte) + CRC ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:2:3","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"Write 时序图： PN512： 发送: A0 + addr + CRC 接收: ACK(A0)/NAK/timeout(5ms) + NO CRC 发送: data(16byte) + CRC 接收: ACK(A0)/NAK/timeout(10ms) + NO CRC ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:2:4","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"Other Increment \u0026 Decrement \u0026 Restore \u0026 Transfer 这些命令也像上面一样对照着 M1 卡手册和 PN512 手册查看，这里不再赘述了。 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:2:5","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["wireless"],"content":"总结 当初看 RFID 怎么读写时特别困惑，因为读卡器手册上只有寄存器表示什么，没有说里面值要填什么值。 后来看了 M1 手册和例子才知道，哦，原来这个协议就是这么规定的。 所以有时理解标准协议不如看看相关芯片手册，也许会有惊喜。 ","date":"2018-05-18","objectID":"/article/2018/05/18/rfid-iso14443a/:3:0","tags":["rfid","pn512","m1"],"title":"RFID：ISO14443A","uri":"/article/2018/05/18/rfid-iso14443a/"},{"categories":["tools"],"content":"博客图床","date":"2018-05-15","objectID":"/article/2018/05/15/figure-bed/","tags":["python","flickr"],"title":"博客图床","uri":"/article/2018/05/15/figure-bed/"},{"categories":["tools"],"content":"原来我的博客使用七牛作为图床，速度挺快但是无法免费使用 https，就想着更换一个图床（其实就是不折腾就难受）。 更换图床有两处较为麻烦： markdown 文档图片链接批量替换，并且有时没有规律可循。 大量图片上传到新的图床并且获得图片链接地址。 基于以上的考虑我对博客做了如下调整。 ","date":"2018-05-15","objectID":"/article/2018/05/15/figure-bed/:0:0","tags":["python","flickr"],"title":"博客图床","uri":"/article/2018/05/15/figure-bed/"},{"categories":["tools"],"content":"图片链接处理 hexo 有个 hexo-asset-image 插件可以自动补全图片全路径，我们只需稍微修改下就可以将图片链接地址查找抛给程序处理，而不用一个个手动替换。 我分别对云存储库和其他图库做了区别，说明如下具体代码修改参见 github 。 ","date":"2018-05-15","objectID":"/article/2018/05/15/figure-bed/:1:0","tags":["python","flickr"],"title":"博客图床","uri":"/article/2018/05/15/figure-bed/"},{"categories":["tools"],"content":"云存储 七牛上传时路径可以指定，地址头是固定的，所以上传成功后也就知道图片的外链地址是什么了。 比如： 你建立一个存储空间，七牛分给你的测试域名是 xxx.bkt.clouddn.com 上传一个图片 test.jpg 到该存储空间，你设置的前缀是 myway/test/ 那么该图片的外链地址就是 http://xxx.bkt.clouddn.com/myway/test/test.jpg 这种类型的图床只需要定义一套自己的上传路径规则就好了，外链地址完全可以自动生成。 ","date":"2018-05-15","objectID":"/article/2018/05/15/figure-bed/:1:1","tags":["python","flickr"],"title":"博客图床","uri":"/article/2018/05/15/figure-bed/"},{"categories":["tools"],"content":"相册 其他图床多半是相册类型的，你不能控制外链的格式和名字。 比如： 你上传一个 test.jpg 图片到新浪相册 查看外链你会发现是 https://wx4.sinaimg.cn/tesdf/bc323245hj23402c0b29.jpg，完全没有规律可言 这种情况你需要一个源文件名和地址对应表，我使用的是 json 文件。 { \"test.jpg\": \"https://wx4.sinaimg.cn/tesdf/bc323245hj23402c0b29.jpg\" } 当然这种需要你的所有源文件名不能重复。 ","date":"2018-05-15","objectID":"/article/2018/05/15/figure-bed/:1:2","tags":["python","flickr"],"title":"博客图床","uri":"/article/2018/05/15/figure-bed/"},{"categories":["tools"],"content":"图床选择 ","date":"2018-05-15","objectID":"/article/2018/05/15/figure-bed/:2:0","tags":["python","flickr"],"title":"博客图床","uri":"/article/2018/05/15/figure-bed/"},{"categories":["tools"],"content":"七牛 有免费 10G 的存储空间，而且可以自动处理图片加水印什么的。 网上有很多批量上传工具，我就不说了，这是我用的脚本代码 qiniu-upload.py。 目前测试用的外链地址取消了，所以也没有办法做图床了。 ","date":"2018-05-15","objectID":"/article/2018/05/15/figure-bed/:2:1","tags":["python","flickr"],"title":"博客图床","uri":"/article/2018/05/15/figure-bed/"},{"categories":["tools"],"content":"本地 使用静态博客本身路径存储（要挂一起挂），一般博客（一年更不了几次）完全够用了。 但是图片要保存到 git 中，需要大文件管理，目前我用的 Git LFS。 安装好后执行以下操作初始化： git lfs install git lfs track \"*.png\" git lfs track \"*.jpg\" git add .gitattributes ","date":"2018-05-15","objectID":"/article/2018/05/15/figure-bed/:2:2","tags":["python","flickr"],"title":"博客图床","uri":"/article/2018/05/15/figure-bed/"},{"categories":["tools"],"content":"flickr 我选择这个主要是空间没有限制，api 也很丰富，唯一的缺点就是国内会被屏蔽吧。我一般放的是自己拍摄的照片，也都是自我欣赏所以这点对我没有影响。 准备 申请自己的 API Key。 因为我使用的是 python，安装 flickrapi 库：pip install flickrapi。 翻墙，这个很重要，我一开始怎么试都是失败就是因为没有翻墙。。。 获得权限 flickr = flickrapi.FlickrAPI(api_key, api_secret) flickr.authenticate_via_browser(perms='write') 注意的是这种授权第一次会弹出一个网页界面，所以系统里面必须要有浏览器。 授权通过后你的用户下会产生一个 .flickr 文件夹里面存放着授权信息。 上传图片 rsp = flickr.upload(filename=\"xxx.jpg\") if rsp.attrib['stat'] == 'ok': photo_id = rsp.find('photoid').text 详细说明，这样获得了上传后图片 ID。 获得外链地址 使用 flickr.photos.getSizes API 可以获得图片各种大小的外链地址。 开始不清楚 flickrapi 库怎么调用这个 API，后来发现好像是有规律的，photos.getSizes 就是 photos_getSizes。 rsp = flickr.photos_getSizes(photo_id=photo_id) sizes = rsp.find('sizes') urls = {} for size in sizes: info = size.attrib urls[info['label']] = info['source'] if 'Medium 800' in urls: url = urls['Medium 800'] print(url) 返回数据处理可以查看 Response parser: ElementTree 文档。 保存 将图片文件名和地址保存为 json 文件。 全部代码参见 flickr-upload.py。 ","date":"2018-05-15","objectID":"/article/2018/05/15/figure-bed/:2:3","tags":["python","flickr"],"title":"博客图床","uri":"/article/2018/05/15/figure-bed/"},{"categories":["troubleshooting"],"content":"VirtualBox 虚拟网卡消失问题","date":"2018-03-08","objectID":"/article/2018/03/08/virtualbox-virtual-network-disappear/","tags":["vm","win"],"title":"VirtualBox 虚拟网卡消失问题","uri":"/article/2018/03/08/virtualbox-virtual-network-disappear/"},{"categories":["troubleshooting"],"content":"VirtualBox 一般安装时会在本地新建一个 VirtualBox Host-Only Network 的虚拟网卡，本机可以通过这个网卡和虚拟机通信。 然而 Windows 在升级时有可能会丢失掉这个网卡（比如：Windows8 升级到 Windows10），而且升级后原来的网卡还有残留配置，导致 VirtualBox 再新建一个网卡名字会变成 VirtualBox Host-Only Network #2，并且在设置原来的地址时会报地址重复占用的提示。 新建虚拟网卡显示如下 修改 IP 地址为原来的会报如下错误 怎么删除这个消失的网卡困扰了我一段时间，直到英文搜索到「Problem after updating to Windows 10 1703」这个讨论，找到了解决办法。（PS：英语真的很重要啊！so sad） 其中列出了具体步骤，不过我没有卸载再安装 VirtualBox，我的步骤如下： 关闭虚拟机软件 下载 RunAsTI，这个不用安装解压就可以使用，感觉很强大啊。之前注册表被保护都看不到里面的内容，使用这个工具后就可以了。 运行 RunAsTI64 打开 cmd，输入 regedit 打开注册表 查找 \\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\NetworkSetup2\\Interfaces\\ 下残留 Virtualbox Host-Only Network Adapter 信息项，并将其删除。 重启电脑 好了，问题解决了。 ","date":"2018-03-08","objectID":"/article/2018/03/08/virtualbox-virtual-network-disappear/:0:0","tags":["vm","win"],"title":"VirtualBox 虚拟网卡消失问题","uri":"/article/2018/03/08/virtualbox-virtual-network-disappear/"},{"categories":["tools"],"content":"xShell 脚本","date":"2017-12-06","objectID":"/article/2017/12/06/xshell-script/","tags":["vbs","script"],"title":"xShell 脚本","uri":"/article/2017/12/06/xshell-script/"},{"categories":["tools"],"content":"最近需要写个自动交互脚本，发现 xShell 可以直接运行，真是方便不少。 xShell 支持三种脚本文件：VBScript、JavaScript 和 Python。 ","date":"2017-12-06","objectID":"/article/2017/12/06/xshell-script/:0:0","tags":["vbs","script"],"title":"xShell 脚本","uri":"/article/2017/12/06/xshell-script/"},{"categories":["tools"],"content":"VBScript 文件名以 vbs 结尾，sublime 可以安装插件（VBScript）方便调试。 ","date":"2017-12-06","objectID":"/article/2017/12/06/xshell-script/:1:0","tags":["vbs","script"],"title":"xShell 脚本","uri":"/article/2017/12/06/xshell-script/"},{"categories":["tools"],"content":"基本语法1 常量2 VbCrLf：换行符 Chr(8)：退格符 VbTab：制表符 VbCr：回车符 变量 字符串：str=\"I am string\" 数组： dim array(n) array(0)=\"1\" array(1)=\"2\" . . . array(n-1)=\"n\" 函数 定义： Sub FuncName(argv1, argv2) ... End Sub 调用： FuncName input1, input2 不需要加括号 ","date":"2017-12-06","objectID":"/article/2017/12/06/xshell-script/:1:1","tags":["vbs","script"],"title":"xShell 脚本","uri":"/article/2017/12/06/xshell-script/"},{"categories":["tools"],"content":"例子3 进入 /root 路径，新建文件写入「Hello World」并保存。 ready=\"## \" Sub send(str) xsh.Screen.Send str xsh.Session.Sleep 100 xsh.Screen.Send VbCr xsh.Screen.WaitForString ready End Sub Sub main xsh.Screen.Synchronous = True send \"cd /root/\" xsh.Screen.Send \"vi test\" xsh.Session.Sleep 100 xsh.Screen.Send VbCr xsh.Session.Sleep 100 xsh.Screen.Send \"a\" xsh.Session.Sleep 100 xsh.Screen.Send \"Hello World\" xsh.Screen.Send VbCr xsh.Screen.Send Chr(27) xsh.Screen.Send \":wq\" xsh.Screen.Send VbCr End Sub ","date":"2017-12-06","objectID":"/article/2017/12/06/xshell-script/:1:2","tags":["vbs","script"],"title":"xShell 脚本","uri":"/article/2017/12/06/xshell-script/"},{"categories":["tools"],"content":"Python 需要安装 Python，有些麻烦。 W3school-VBS ↩︎ VBS 中的转义符 ↩︎ xShell 终端调用 VBS 脚本使用方法说明 ↩︎ ","date":"2017-12-06","objectID":"/article/2017/12/06/xshell-script/:2:0","tags":["vbs","script"],"title":"xShell 脚本","uri":"/article/2017/12/06/xshell-script/"},{"categories":["development"],"content":"ImageMagick 图像处理","date":"2017-12-01","objectID":"/article/2017/12/01/imagemagick/","tags":["image"],"title":"ImageMagick","uri":"/article/2017/12/01/imagemagick/"},{"categories":["development"],"content":"最近使用一下 ImageMagick 处理图片，现在记录一下常用几个函数。 官方文档在这里。 直接贴一个例子1： 将彩色图片转换灰度图片保存。 int main (int argc, char **argv) { if (argc \u003c 2) { printf(\"%s picture.\\n\", argv[0]); exit(1); } const char *filename = argv[1]; MagickWandGenesis(); MagickWand *images = NewMagickWand(); if(!MagickReadImage(images, filename)) { printf(\"E: %s read failed.\\n\", filename); exit(2); } printf(\"Read: %s\\n\", MagickGetImageFilename(images)); int width = MagickGetImageWidth(images); int height = MagickGetImageHeight(images); size_t bloblen = width * height; unsigned char *blob = malloc(bloblen); if(!MagickExportImagePixels(images, 0, 0, width, height, \"I\", CharPixel, blob)) { printf(\"E: read picture failed.\\n\"); exit(3); } // write MagickWand *img = NewMagickWand(); PixelWand *pix = NewPixelWand(); if (!MagickNewImage(img, width, height, pix)) { printf(\"E: new image failed.\\n\"); exit(4); } if (!MagickImportImagePixels(img, 0, 0, width, height, \"I\", CharPixel, blob)) { printf(\"E: write picture failed.\\n\"); exit(5); } MagickWriteImage(img, \"out.jpg\"); printf(\"Write: out.jpg\\n\"); // clean free(blob); DestroyPixelWand(pix); DestroyMagickWand(img); DestroyMagickWand(images); MagickWandTerminus(); exit(0); } 注： makefile 需要添加 ImageMagick 动态库路径 -I/usr/local/include/ImageMagick-6 -L/usr/local/include/ImageMagick-6/ -lMagickWand-6.Q16 Stack Overflow ↩︎ ","date":"2017-12-01","objectID":"/article/2017/12/01/imagemagick/:0:0","tags":["image"],"title":"ImageMagick","uri":"/article/2017/12/01/imagemagick/"},{"categories":["tools"],"content":"Markdown 语法增强","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"用 Markdown 写文档，主要是省去了排版的麻烦，编辑也简单随便使用个文本编辑器就行。不过也有无力的时候，比如绘图等。 这里我使用一些现成的 js 库，完成一些复杂的功能。当然从简洁的角度这样不太优雅，但是可以保留原始数据方便修改，各有利弊吧。 以下方法使用是 html 语言，所以在 html 中也适用的。 ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:0:0","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"UML 序列图 使用 js-sequence-diagrams 库。 该库可以将文本描述自动生成 UML 序列图。 ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:1:0","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"准备 主要需要以下 js 文件，可以将其下载到本地，也可使用网上在线库。 jquery.min.js underscore-min.js raphael.min.js sequence-diagram-min.js ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:1:1","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"编辑 在 markdown 中开头添加 js 引用路径，如下： \u003cscript src=\"/js/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/js/underscore-min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/js/raphael.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/js/sequence-diagram-min.js\"\u003e\u003c/script\u003e 想要渲染的文本使用 \u003cdiv class=\"diagram\"\u003e\u003c/div\u003e 标记，如下： \u003cdiv class=\"diagram\"\u003e Alice-\u003eBob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u003eAlice: I am good thanks! \u003c/div\u003e 在文件末尾添加动作： \u003cscript\u003e $(\".diagram\").sequenceDiagram({theme: 'hand'}); \u003c/script\u003e ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:1:2","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"结果 Alice-\u003eBob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u003eAlice: I am good thanks! PS: hexo 会渲染 html 代码，造成显示错误，如下可避免 {% raw %} your html {% endraw %} ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:1:3","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"条形图 使用 Chart.js 库。 ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:2:0","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"准备 主要需要以下 js 文件： jquery.min.js Chart.min.js 为了方便使用，再添加一个解析文件（chart.md.js）： (function($){ var methods = { bar : function() { var data = $.parseJSON(this.text()) // get data var datasets = []; var color = Math.random() * 360; for (var i = 0; i \u003c data[`data`].length; i++) { var dataset = {}; dataset.label = data[`data`][i][`label`]; dataset.data = data[`data`][i][`data`]; dataset.borderWidth = 1; dataset.hoverBorderWidth = 2; var h = Math.round(color + (i * 137.5)) % 360; var l = Math.round(Math.random() * 20) + 60; dataset.backgroundColor = 'hsla(' + h + ',70%,' + l + '%,0.4)'; dataset.borderColor = 'hsla(' + h + ',70%,' + l + '%,1)'; datasets[i] = dataset; } // get bar type var type = 'bar'; var xstacked = false; var ystacked = false; if (data.hasOwnProperty(\"type\")) { var ss = data[`type`]; if (ss.indexOf('horiz') \u003e= 0) { type = 'horizontalBar'; if (ss.indexOf('over') \u003e= 0) { ystacked = true; } } else { if (ss.indexOf('over') \u003e= 0) { xstacked = true; } } if (ss.indexOf('stack') \u003e= 0) { xstacked = true; ystacked = true; } } new Chart(this, { type: type, data: { labels: data[`item`], datasets: datasets, }, options: { responsive: false, title: { display: data.hasOwnProperty(\"title\"), text: data[`title`], }, legend: { display: data[`data`][0].hasOwnProperty(\"label\"), }, scales: { xAxes: [{ stacked: xstacked, ticks: { beginAtZero: true, }, }], yAxes: [{ stacked: ystacked, ticks: { beginAtZero: true, }, }], }, tooltips: { mode: (xstacked || ystacked) ? 'label' : 'single', }, }, }); } }; $.fn.chart = function( method ){ if ( methods[method] ) { return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 )); } else if ( typeof method === 'object' || ! method ) { return methods.init.apply( this, arguments ); } else { $.error( 'Method ' + method + ' does not exist on jQuery.chart' ); } }; })(jQuery); ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:2:1","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"修改 在 markdown 中开头添加 js 引用路径，如下： \u003cscript src=\"/js/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/js/Chart.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/js/chart.md.js\"\u003e\u003c/script\u003e 想要渲染的文本使用 \u003ccanvas class=\"bar\" width=\"xxx\" height=\"xxx\"\u003e\u003c/canvas\u003e 标记，数据使用 json 格式，如下： \u003ccanvas class=\"bar\" width=\"400\" height=\"400\"\u003e { \"title\": \"I have Title\", \"item\": [\"Red\", \"Blue\", \"Yellow\", \"Green\", \"Purple\", \"Orange\"], \"type\": \"horiz stack\", \"data\": [{ \"label\": \"one\", \"data\": [12, 19, 3, 5, 2, 3] },{ \"label\": \"two\", \"data\": [23, 34, 1, 0, 39, 22] },{ \"label\": \"thrid\", \"data\": [21, 0, 1, 20, 12, 15] }] } \u003c/canvas\u003e type： horiz：条形图水平显示 over：一个条形图多个时叠加显示 stack：一个条形图多个时累加显示 在文件末尾添加动作： \u003cscript\u003e $(\".bar\").each(function(){ $(this).chart('bar') }) \u003c/script\u003e ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:2:2","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"结果 { \"title\": \"I have Title\", \"item\": [\"Red\", \"Blue\", \"Yellow\", \"Green\", \"Purple\", \"Orange\"], \"type\": \"horiz stack\", \"data\": [{ \"label\": \"one\", \"data\": [12, 19, 3, 5, 2, 3] },{ \"label\": \"two\", \"data\": [23, 34, 1, 0, 39, 22] },{ \"label\": \"thrid\", \"data\": [21, 0, 1, 20, 12, 15] }] } ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:2:3","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"解析器修改 markdown 渲染有不同的解析器，各个可能有差异，有些需要修改才能支持自己添加的 js 文件。 ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:3:0","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["tools"],"content":"OmniMarkupPreviewer OmniMarkupPreviewer 是 sublime 的插件，可以实时显示渲染 markdown 文档。 新添加的 js 文件可以放在以下目录： C:\\Users\\xxx\\AppData\\Roaming\\Sublime Text 3\\Packages markdown 文件中 js 的路径如下： \u003cscript src=\"/public/xxx.js\"\u003e\u003c/script\u003e ","date":"2017-09-07","objectID":"/article/2017/09/07/markdown-enhance/:3:1","tags":["markdown","js","web"],"title":"Markdown 增强","uri":"/article/2017/09/07/markdown-enhance/"},{"categories":["embedded"],"content":"Arduino 101 Serial 实现详解","date":"2017-07-03","objectID":"/article/2017/07/03/arduino-101-serial-implementation-details/","tags":["arduino","quark","usb"],"title":"Arduino 101 Serial 实现详解","uri":"/article/2017/07/03/arduino-101-serial-implementation-details/"},{"categories":["embedded"],"content":"Arduino 101 连接 PC 是通过一条方口 USB 数据线，并且可以通过这条数据线接收板子输出 debug 调试。 那么这是如何实现的呢？ 这部分没有完全看透，只记录下目前收获（也许有误）。 ","date":"2017-07-03","objectID":"/article/2017/07/03/arduino-101-serial-implementation-details/:0:0","tags":["arduino","quark","usb"],"title":"Arduino 101 Serial 实现详解","uri":"/article/2017/07/03/arduino-101-serial-implementation-details/"},{"categories":["embedded"],"content":"概述 Arduino 中操作串口是通过 Serial1 类。 初始化： void setup() { Serial.begin(9600); // 波特率设置为 9600 while(!Serial); // 等待串口初始化完成 } 发送： void loop() { Serial.print(\"Hello World!\\n\"); } 接收： void serialEvent(){ // Called when data is available. Use Serial.read() to capture this data. Serial.print(Serial.read()); } ","date":"2017-07-03","objectID":"/article/2017/07/03/arduino-101-serial-implementation-details/:1:0","tags":["arduino","quark","usb"],"title":"Arduino 101 Serial 实现详解","uri":"/article/2017/07/03/arduino-101-serial-implementation-details/"},{"categories":["embedded"],"content":"分析 查看代码时发现了应用程序入口其实在 main.cpp 中，如下： C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\cores\\arduino\\main.cpp int main( void ) { initVariant(); #if defined(USBCON) USBDevice.attach(); #endif setup(); for (;;) /* This infinite loop is intentional and requested by design */ { loop(); if (serialEventRun) serialEventRun(); } return 0; } 从中可以看到 setup loop 等函数，这就是通用的 Arduino 代码函数块，可以发现 loop 和 serialEvent 其实是顺序轮询方式，并不是真正中断。 ","date":"2017-07-03","objectID":"/article/2017/07/03/arduino-101-serial-implementation-details/:2:0","tags":["arduino","quark","usb"],"title":"Arduino 101 Serial 实现详解","uri":"/article/2017/07/03/arduino-101-serial-implementation-details/"},{"categories":["embedded"],"content":"初始化 Serial 部分的源码又在哪里呢？查找后发现对象初始化部分： C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\variants\\arduino_101\\variant.cpp uart_init_info info_cdc; CDCSerialClass Serial(\u0026info_cdc); RingBuffer rx_buffer_uart; RingBuffer tx_buffer_uart; uart_init_info info_uart; UARTClass Serial1(\u0026info_uart, \u0026rx_buffer_uart, \u0026tx_buffer_uart); 原来 Serial 是全局变量，CDCSerialClass 的构造函数只是赋值，并没有特殊操作。 现在已知如下（和板子定义一致）： Serial 表示 USB2 串口 Serial1 表示 UART 串口 接下来的操作在 initVariant() 中： void initVariant( void ) { /* Initialise CDC-ACM shared buffers pointers, provided by LMT */ Serial.setSharedData(shared_data-\u003ecdc_acm_buffers); ... } Serial.setSharedData 只是赋值串口对象指针。 C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\cores\\arduino\\CDCSerialClass.cpp void CDCSerialClass::setSharedData(struct cdc_acm_shared_data *cdc_acm_shared_data) { this-\u003e_shared_data = cdc_acm_shared_data; this-\u003e_rx_buffer = cdc_acm_shared_data-\u003erx_buffer; this-\u003e_tx_buffer = cdc_acm_shared_data-\u003etx_buffer; } 其中 shared_data 是芯片中的 SRAM3 地址为 0xA8000000，共 80K4。 关于这段内存的作用，我推测是和内核部分进行交互，因为 CDCSerialClass 中并没有对寄存器的操作。 而内核部分也有同样的结构，并且会读取标志位以及设置标志位（内核部分没有详细查看）。 内核相关理解如下： 代码入口在 CODK\\CODK-A\\x86\\projects\\arduino101\\quark\\main.c 驱动部分代码 CODK\\CODK-A\\x86\\bsp\\src\\drivers\\usb（usb_driver_intf 没有找到声明地方） ","date":"2017-07-03","objectID":"/article/2017/07/03/arduino-101-serial-implementation-details/:2:1","tags":["arduino","quark","usb"],"title":"Arduino 101 Serial 实现详解","uri":"/article/2017/07/03/arduino-101-serial-implementation-details/"},{"categories":["embedded"],"content":"其他 以 Serial.print 实现为例，使用该函数会向串口发送字符串。 CDCSerialClass 中并没有定义 print 的方法，此方法乃是继承 class Print，其所有继承关系如下： CDCSerialClass-\u003eHardwareSerial-\u003eStream-\u003ePrint 某个方法的实现如下： C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\cores\\arduino\\Print.cpp size_t Print::print(char c) { return write(c); } 而 write 方法在 CDCSerialClass 类中被重写为向串口发送数据，如此便实现了 Serial.print 的功能。 ","date":"2017-07-03","objectID":"/article/2017/07/03/arduino-101-serial-implementation-details/:2:2","tags":["arduino","quark","usb"],"title":"Arduino 101 Serial 实现详解","uri":"/article/2017/07/03/arduino-101-serial-implementation-details/"},{"categories":["embedded"],"content":"疑问 CDCSerialClass 中波特率设置似乎没有作用。 void CDCSerialClass::init(const uint32_t dwBaudRate, const uint8_t modeReg) { /* Set a per-byte write delay approximately equal to the time it would * take to clock out a byte on a standard UART at this baud rate */ _writeDelayUsec = 8000000 / dwBaudRate; /* Make sure both ring buffers are initialized back to empty. * Empty the Rx buffer but don't touch Tx buffer: it is drained by the * LMT one way or another */ _rx_buffer-\u003etail = _rx_buffer-\u003ehead; _shared_data-\u003edevice_open = true; } 以上为初始化部分，从中可以看到 dwBaudRate 只计算了 _writeDelayUsec，没有传递到 _shared_data 中。 查找代码又会发现 _writeDelayUsec 没有在其他地方被调用过，那么该波特率还有作用吗？ 为此我尝试在电脑上随便修改波特率，并和板子通信，发现波特率不匹配也可以通信，不知道是不是因为该口是 USB 虚拟串口的原因？ 相对应的 Serial1 UARTClass 的 init 中是包含波特率设置代码的。 ","date":"2017-07-03","objectID":"/article/2017/07/03/arduino-101-serial-implementation-details/:2:3","tags":["arduino","quark","usb"],"title":"Arduino 101 Serial 实现详解","uri":"/article/2017/07/03/arduino-101-serial-implementation-details/"},{"categories":["embedded"],"content":"修改 添加 printf 方法5。 我使用的是添加 Print::printf，修改后可在 Serial 中使用 printf 方法了。 C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\cores\\arduino\\Print.cpp #include \u003cstdarg.h\u003e #define PRINTF_BUF 80 size_t Print::printf(const char *format, ...) { char buf[PRINTF_BUF]; va_list ap; va_start(ap, format); vsnprintf(buf, sizeof(buf), format, ap); for(char *p = \u0026buf[0]; *p; p++) { if(*p == '\\n') write('\\r'); write(*p); } va_end(ap); } Serial func ↩︎ USB CDC is a composite Universal Serial Bus device class ↩︎ static random access memory ↩︎ Intel® Quark™ SE Microcontroller C1000 Datasheet, Table 24, Mapping Address Spaces ↩︎ Arduino printf ↩︎ ","date":"2017-07-03","objectID":"/article/2017/07/03/arduino-101-serial-implementation-details/:3:0","tags":["arduino","quark","usb"],"title":"Arduino 101 Serial 实现详解","uri":"/article/2017/07/03/arduino-101-serial-implementation-details/"},{"categories":["tools"],"content":"GCC 常用","date":"2017-06-15","objectID":"/article/2017/06/15/gcc/","tags":["gcc","c"],"title":"GCC 常用","uri":"/article/2017/06/15/gcc/"},{"categories":["tools"],"content":"记录一些编译遇到的问题。 首先推荐陈皓的《跟我一起写 Makefile》，可以算是启蒙书了，一些参数的含义在这里也可以找到，非常方便。 ","date":"2017-06-15","objectID":"/article/2017/06/15/gcc/:0:0","tags":["gcc","c"],"title":"GCC 常用","uri":"/article/2017/06/15/gcc/"},{"categories":["tools"],"content":"动态库导入静态库 遇到需要编译一个动态库，但是其中包含两个静态库，怎么样能把他们编译到一起呢？ 目标：libmylib.so 源：src1.c src2.c 库：liba.a libb.a 依赖：libmylib.so -\u003e libb.a -\u003e liba.a 目录： . ├── liba │ └── liba.a ├── libb │ └── libb.a ├── src1.c └── src2.c 编译： gcc -fPIC -Wall src1.c src2.c -shared -o libmy.so -Llibb -lb -Lliba -la 说明： -L 后接静态库所在目录位置 -l 后接静态库名字，去掉前面的 lib 以及文件类型 .a -Lxxx -lxxx 需要放在最后 两个以上静态库时，被依赖的放在后面，如上 b 依赖 a，a 在后 验证：使用以下命令确保未出现静态库中的函数名 nm libmylib.so | grep \"U \" ","date":"2017-06-15","objectID":"/article/2017/06/15/gcc/:1:0","tags":["gcc","c"],"title":"GCC 常用","uri":"/article/2017/06/15/gcc/"},{"categories":["embedded"],"content":"Arduino 101 GPIO 实现详解","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"最近买了一块 Arduino 101 开发版，准备学习研究一下。 首先从最简单的 GPIO 开始。 ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:0:0","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"概述 要知道 GPIO 基本上都是 CPU 直接控制的，我们先查找一下 CPU 的资料。 ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:1:0","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"CPU 主控制器是 Intel® Curie™ Module 1，其整体结构图如下： 这是一个集成的控制芯片，我们发现其中的真正微控制器其实是 Intel® Quark™ SE Microcontroller C1000 2，其结构框图如下： ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:1:1","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"GPIO 手册中 1.10 节概述了 GPIO 控制器如下： GPIO Controller Provides 32 independently configurable GPIOs All GPIOs are interrupt capable, supporting level sensitive and edge triggered modes Debounce logic for interrupt source 16 additional GPIOs available via Sensor Subsystem 6 additional Always-on interrupt and wake capable GPIOs 概括来说 GPIO 由三部分组成： 32 个独立配置口（暂用 SOC_GPIO_32 代表） 16 个额外通过传感器子系统提供（暂用 SS_GPIO_16 代表） 6 个额外提供中断及唤醒口（暂用 AON_GPIO_6 代表） ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:1:2","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"分析 Arduino 自带的 Blink 程序就是控制 GPIO 高低，从而开关 LED 灯。 // the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:2:0","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"初始化 void pinMode( uint8_t pin, uint8_t mode ) pin: Arduino 定义的 GPIO 编号 mode: INPUT，INPUT_PULLUP，OUTPUT 那么这个函数是怎么一步步配置到寄存器的呢？ 首先找到 pinMode 函数实现如下： C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\cores\\arduino\\wiring_digital.c void pinMode( uint8_t pin, uint8_t mode ) { /* 101 NUM_DIGITAL_PINS=32 */ if (pin \u003e= NUM_DIGITAL_PINS) return; /* g_APinDescription 为映射结构体数组 */ PinDescription *p = \u0026g_APinDescription[pin]; ... } PinDescription 映射配置结构体包含如下： C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\cores\\arduino\\Arduino.h typedef const struct _PinDescription { uint32_t ulGPIOId; // GPIO port pin uint32_t ulGPIOPort; // GPIO port ID uint32_t ulGPIOType; // LMT or SS uint32_t ulGPIOBase; // GPIO register base address uint32_t ulSocPin; // SoC pin number uint32_t ulPinMode; // Current SoC pin mux mode uint32_t ulPwmChan; // PWM channel uint32_t ulPwmScale; // PWM frequency scaler uint32_t ulAdcChan; // ADC channel uint32_t ulInputMode; // Pin mode } PinDescription; g_APinDescription 就是提前配置好的全局结构体数组，输入 pin=LED_BUILTIN，即编号十三引脚。 C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\variants\\arduino_101\\pins_arduino.h static const uint8_t LED_BUILTIN = 13; 而十三引脚的映射如下： C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\variants\\arduino_101\\variant.cpp PinDescription g_APinDescription[]={ ... {8, SOC_GPIO_32, SOC_GPIO, SOC_GPIO_BASE_ADDR, 42, GPIO_MUX_MODE, INVALID, INVALID, INVALID, INPUT_MODE}, // Arduino IO13 ... }; mode=OUTPUT 把编号十三引脚设置为输出模式，进入如下分支（ulGPIOType=SOC_GPIO）： void pinMode( uint8_t pin, uint8_t mode ) { ... if (mode == OUTPUT) { ... else if (p-\u003eulGPIOType == SOC_GPIO) { uint32_t reg = p-\u003eulGPIOBase + SOC_GPIO_SWPORTA_DDR; SET_MMIO_BIT(reg, p-\u003eulGPIOId); } } ... } 可以看出映射到的寄存器地址是 0xB0000C04， （reg = SOC_GPIO_BASE_ADDR + SOC_GPIO_SWPORTA_DDR） C:\\Users\\XXX\\AppData\\Local\\Arduino15\\packages\\Intel\\hardware\\arc32\\2.0.2\\system\\libarc32_arduino101\\common\\scss_registers.h #define SOC_GPIO_BASE_ADDR 0xB0000C00 #define SOC_GPIO_SWPORTA_DDR 0x04 SET_MMIO_BIT 是在 0xB0000C04 地址 bit 8 位设置为 1。 查找手册相应说明如下： 即把 SOC_GPIO_32[8] 设置为输出，那么 LED 实际上到底是不是 GPIO[8] 呢？ 原理图 LED 部分如下： 而 ATPSCK/IO2_3V_IO13 和 Curie 芯片有两处相连接，分别是 SPI1_M_SCK 和 ATP_SPI_S_SCK， 在 Curie 中找到相应引脚信息如下： 如此证明之前的推测是正确的，SOC_GPIO_32[8] 控制着 LED 开关，GPIO 为高时，LED 亮，反之，LED 灭。 ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:2:1","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"输出 void digitalWrite( uint8_t pin, uint8_t val ) pin: 0~31 val: HIGH，LOW ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:2:2","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"输入 int digitalRead( uint8_t pin ) pin: 0~31 ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:2:3","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"总结 由上面分析可知，程序是通过一个事先定义好的映射表来查找对应的寄存器地址，再来设置相应的数据。 较重要的几个文件是： wiring_digital.c：设置 GPIO 寄存器，包括初始化，读和写 variant.cpp：配置映射表 scss_registers.h：寄存器地址 ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:3:0","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"配置 SOC_GPIO_32 GPIO_SWPORTA_DDR 设置输入/输出口 PMUX_PULLUP [0..3] 设置是否使能上拉 这是一个多路复用寄存器可以设置外部引脚是否为上拉输入， 寄存器和引脚的映射，我没有找到明确的解释，但是查看官方的软件说明3后， 我基本确定 4 × 32 的寄存器标号即 EXTERNAL_PAD_XX 中 XX 标号4。 如：GPIO[8] 为 EXTERNAL_PAD_42 那么如果设置其为上拉， 则，PMUX_PULLUP[1] bit 10 = 1。 ps，手册中有两种封装，因为我们用的是 Curie 芯片，该芯片使用的是 WLCSP 封装，所以查看引脚表格也是看该封装的。 PMUX_SEL [0..5] 设置引脚复用 SS_GPIO_16 在手册中我没有找到该部分寄存器定义，以下根据程序得出 SS_GPIO0_SWPORTA_DDR or SS_GPIO1_SWPORTA_DDR 设置输入/输出 PMUX_PULLUP [0..3] 设置是否使能上拉 PMUX_SEL [0..5] 设置引脚复用 AON_GPIO_6 GPIO_AON_SWPORTA_DDR 设置是输入/输出 PMUX_PULLUP [0..3] 设置是否使能上拉 PMUX_SEL [0..5] 设置引脚复用 ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:3:1","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"读 SOC_GPIO_32 读取 GPIO_EXT_PORTA 寄存器状态 SS_GPIO_16 读取 SS_GPIO_EXT_PORTA 寄存器状态 AON_GPIO_6 读取 GPIO_AON_EXT_PORTA 寄存器状态 ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:3:2","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["embedded"],"content":"写 SOC_GPIO_32 写入 GPIO_SWPORTA_DR 寄存器 设置 PMUX_PULLUP [0..3] 是否使能上拉 SS_GPIO_16 写入 SS_GPIO_SWPORTA_DR 寄存器 设置 PMUX_PULLUP [0..3] 是否使能上拉 AON_GPIO_6 写入 GPIO_AON_SWPORTA_DR 寄存器 设置 PMUX_PULLUP [0..3] 是否使能上拉 Datasheet for the Intel® Curie™ Module ↩︎ Intel® Quark™ SE Microcontroller C1000 Datasheet ↩︎ Intel®Quark™Microcontroller Software Interface Pin Multiplexing Reference Guide ↩︎ Intel® Quark™ SE Microcontroller C1000 Datasheet, 3.5, Ballmap Name ↩︎ ","date":"2017-04-20","objectID":"/article/2017/04/20/arduino-101-gpio-implementation-details/:3:3","tags":["arduino","quark","gpio"],"title":"Arduino 101 GPIO 实现详解","uri":"/article/2017/04/20/arduino-101-gpio-implementation-details/"},{"categories":["development"],"content":"使用 golang 绘制一个带颜色的谢尔宾斯基三角形。 ","date":"2017-04-07","objectID":"/article/2017/04/07/sierpinski-triangle/:0:0","tags":["go","draw","fractal"],"title":"谢尔宾斯基三角形","uri":"/article/2017/04/07/sierpinski-triangle/"},{"categories":["development"],"content":"定义1 使用去掉中心法： 取一个实心的三角形（多数使用等边三角形） 沿三边中点的连线，将它分成四个小三角形 去掉中间的那一个小三角形 对其余三个小三角形重复 1~4 步骤 ","date":"2017-04-07","objectID":"/article/2017/04/07/sierpinski-triangle/:1:0","tags":["go","draw","fractal"],"title":"谢尔宾斯基三角形","uri":"/article/2017/04/07/sierpinski-triangle/"},{"categories":["development"],"content":"实现 ","date":"2017-04-07","objectID":"/article/2017/04/07/sierpinski-triangle/:2:0","tags":["go","draw","fractal"],"title":"谢尔宾斯基三角形","uri":"/article/2017/04/07/sierpinski-triangle/"},{"categories":["development"],"content":"三角形 因为需要上色，首先需要一个三角形填充函数。 我的做法是首先将三角形四边边界求出，然后逐点判断是否在三角形内部23。 const ( _TRIANGLE_SIDE = false ) func triangle_cross(a, b, c image.Point) int { ab := image.Point{b.X - a.X, b.Y - a.Y} ac := image.Point{c.X - a.X, c.Y - a.Y} return ab.X*ac.Y - ab.Y*ac.X } func triangle_right_side(a, b, c image.Point) bool { if triangle_cross(a, b, c) \u003e 0 { return true } return false } /* * 排序 * 最靠近 x 轴的点为第一个点，剩下逆时针排序 */ func triangle_sort(a, b, c image.Point) (image.Point, image.Point, image.Point) { sort := []image.Point{a, b, c} n := 0 for i := 1; i \u003c 3; i++ { if sort[i].Y \u003c sort[n].Y { n = i } else if sort[i].Y == sort[n].Y { if sort[i].X \u003c sort[n].X { n = i } } } if n != 0 { t := sort[0] sort[0] = sort[n] sort[n] = t } if triangle_right_side(sort[0], sort[1], sort[2]) == _TRIANGLE_SIDE { return sort[0], sort[1], sort[2] } return sort[0], sort[2], sort[1] } func triangle_min(a, b int) int { if a \u003c b { return a } return b } func triangle_max(a, b int) int { if a \u003e b { return a } return b } func triangle_1(img *image.RGBA, A, B, C image.Point, c color.Color) { A, B, C = triangle_sort(A, B, C) // fmt.Println(A, B, C) // 扫描正方形 x_min, x_max := A.X, A.X y_min, y_max := A.Y, A.Y x_min = triangle_min(x_min, B.X) x_min = triangle_min(x_min, C.X) x_max = triangle_max(x_max, B.X) x_max = triangle_max(x_max, C.X) y_min = triangle_min(y_min, B.Y) y_min = triangle_min(y_min, C.Y) y_max = triangle_max(y_max, B.Y) y_max = triangle_max(y_max, C.Y) for i := x_min; i \u003c= x_max; i++ { for j := y_min; j \u003c= y_max; j++ { D := image.Point{i, j} if triangle_right_side(A, B, D) == _TRIANGLE_SIDE \u0026\u0026 triangle_right_side(B, C, D) == _TRIANGLE_SIDE \u0026\u0026 triangle_right_side(C, A, D) == _TRIANGLE_SIDE { img.Set(i, j, c) } } } } 查看资料4由图片启发，可以从顶点开始 S 形式扫描，但是以下的代码并不是所有三角形都能绘制，目前还未想好如何不增加计算时间又能改进的办法。 /* BUG: 一些锐角三角形无法绘出 */ func triangle_2(img *image.RGBA, A, B, C image.Point, c color.Color) { A, B, C = triangle_sort(A, B, C) // fmt.Println(A, B, C) // 蛇字形扫描 x_min, x_max := A.X, A.X x_min = triangle_min(x_min, B.X) x_min = triangle_min(x_min, C.X) x_max = triangle_max(x_max, B.X) x_max = triangle_max(x_max, C.X) x := A.X x_step := 1 for y, loop := A.Y, true; loop; y++ { loop = false for ; x \u003e= x_min \u0026\u0026 x \u003c= x_max; x += x_step { D := image.Point{x, y} if triangle_right_side(A, B, D) == _TRIANGLE_SIDE \u0026\u0026 triangle_right_side(B, C, D) == _TRIANGLE_SIDE \u0026\u0026 triangle_right_side(C, A, D) == _TRIANGLE_SIDE { loop = true img.Set(x, y, c) } else if loop { break } } x_step *= -1 } } ","date":"2017-04-07","objectID":"/article/2017/04/07/sierpinski-triangle/:2:1","tags":["go","draw","fractal"],"title":"谢尔宾斯基三角形","uri":"/article/2017/04/07/sierpinski-triangle/"},{"categories":["development"],"content":"谢尔宾斯基三角 通过递归函数绘制，颜色未指定则随机生成。 func sierpinski_fc(img *image.RGBA, A, B, C image.Point, c []color.Color) { if len(c) \u003c= 0 { return } triangle_1(img, A, B, C, c[0]) D := image.Point{(A.X + B.X) / 2, (A.Y + B.Y) / 2} E := image.Point{(B.X + C.X) / 2, (B.Y + C.Y) / 2} F := image.Point{(C.X + A.X) / 2, (C.Y + A.Y) / 2} c1 := c[1:] sierpinski_fc(img, A, D, F, c1) sierpinski_fc(img, D, B, E, c1) sierpinski_fc(img, F, E, C, c1) } func sierpinski(img *image.RGBA, x, y int) { A := image.Point{x / 2, 0} B := image.Point{0, y} C := image.Point{x, y} c := []color.Color{ // color.RGBA{0xEC, 0xD6, 0xC6, 255}, // color.RGBA{0xD4, 0xDA, 0x90, 255}, // color.RGBA{0xC1, 0xBC, 0x44, 255}, // color.RGBA{0x63, 0x21, 0x5D, 255}, // color.RGBA{0xB4, 0x3C, 0xAC, 255}, // color.RGBA{0xD6, 0x85, 0xCB, 255}, // color.RGBA{0xA1, 0x36, 0x5F, 255}, } s := rand.NewSource(time.Now().Unix()) r := rand.New(s) if len(c) == 0 { for i := 0; i \u003c 7; i++ { t := r.Intn(0xFFFFFF) c_r := uint8(t \u003e\u003e 16) c_b := uint8(t \u003e\u003e 8) c_g := uint8(t) c = append(c, color.RGBA{c_r, c_b, c_g, 255}) } } sierpinski_fc(img, A, B, C, c) } ","date":"2017-04-07","objectID":"/article/2017/04/07/sierpinski-triangle/:2:2","tags":["go","draw","fractal"],"title":"谢尔宾斯基三角形","uri":"/article/2017/04/07/sierpinski-triangle/"},{"categories":["development"],"content":"测试 func Test_sierpinski(t *testing.T) { const ( x = 4000 y = 3500 ) img := image.NewRGBA(image.Rect(0, 0, x, y)) sierpinski(img, x, y) f, _ := os.OpenFile(\"sierpinski.png\", os.O_WRONLY|os.O_CREATE, 0600) defer f.Close() png.Encode(f, img) } 维基百科：谢尔宾斯基三角形 ↩︎ 判断点是否在三角形内 ↩︎ 知乎：三角形填充算法 ↩︎ A Parallel Algorithm for Polygon Rasterization ↩︎ ","date":"2017-04-07","objectID":"/article/2017/04/07/sierpinski-triangle/:3:0","tags":["go","draw","fractal"],"title":"谢尔宾斯基三角形","uri":"/article/2017/04/07/sierpinski-triangle/"},{"categories":["development"],"content":"迭代函数系统 IFS（Iterated Function System），真的是简单即复杂。 ","date":"2017-04-01","objectID":"/article/2017/04/01/ifs/:0:0","tags":["go","draw","fractal"],"title":"IFS","uri":"/article/2017/04/01/ifs/"},{"categories":["development"],"content":"IFS-System 几组二元一次方程组： $$ x_{n+1}=ax_n+by_n+e\\\\ y_{n+1}=cx_n+by_n+f $$ 不同概率下迭代生成所有点的集合。 必要参数： $n$ 组 $a,b,c,d,e,f$ 的参数 $n$ 个概率值 $p$，$\\sum_0^np=1$ 一组起始点 $x_0,y_0$ 一句话总结就是1： 技巧 IFS = 二元一次方程组 + 参数表 + 概率 ","date":"2017-04-01","objectID":"/article/2017/04/01/ifs/:1:0","tags":["go","draw","fractal"],"title":"IFS","uri":"/article/2017/04/01/ifs/"},{"categories":["development"],"content":"实现 使用 golang 生成 IFS 分形图形。 每次迭代需要掷骰子根据概率选择使用那组参数： const ( _IFS_PARAM_NUM = 7 ) func ifs_f(a, b, e, c, d, f float64, x, y float64) (float64, float64) { x1 := a*x + b*y + e y1 := c*x + d*y + f return x1, y1 } func ifs_cal(a [][]float64, x, y float64, r *rand.Rand) (float64, float64) { if len(a) \u003c= 0 || len(a[0]) != _IFS_PARAM_NUM { return x, y } p := r.Float64() c := 0.0 for i := 0; i \u003c len(a); i++ { c += a[i][_IFS_PARAM_NUM-1] if p \u003c= c { x1, y1 := ifs_f( a[i][0], a[i][1], a[i][4], a[i][2], a[i][3], a[i][5], x, y) return x1, y1 } } return x, y } 经过 n 次迭代将点画在画布上。 以下计算两次为了找到边界值，好转换坐标。 func ifs(img *image.RGBA, limit_x, limit_y int) { a := [][]float64{ // tree {0.195, -0.488, 0.344, 0.433, 0.4431, 0.2452, 0.25}, {0.462, 0.414, -0.252, 0.361, 0.2511, 0.5692, 0.25}, {-0.058, -0.07, 0.453, -0.111, 0.5976, 0.0969, 0.25}, {-0.035, 0.07, -0.469, -0.022, 0.4884, 0.5069, 0.2}, {-0.637, 0, 0, 0.501, 0.8562, 0.2513, 0.05}, } s := rand.NewSource(time.Now().Unix()) r := rand.New(s) x0 := r.Float64() y0 := r.Float64() x, y := x0, y0 x_min, x_max := x, x y_min, y_max := y, y loop := limit_x * limit_y / 2 for i := 0; i \u003c loop; i++ { x, y = ifs_cal(a, x, y, r) if x \u003c x_min { x_min = x } if x \u003e x_max { x_max = x } if y \u003c y_min { y_min = y } if y \u003e y_max { y_max = y } } x, y = x0, y0 for i := 0; i \u003c loop; i++ { x, y = ifs_cal(a, x, y, r) ix := (x - x_min) * float64(limit_x) / (x_max - x_min) iy := (y - y_min) * float64(limit_y) / (y_max - y_min) point(img, int(ix), int(iy), color.Gray{0}) } } 生成树形图2如下（图像已经过旋转处理）： IFS-Tree 如果想要方程组参数自动生成可使用如下函数： func ifs_array_generate(r *rand.Rand) [][]float64 { a := [][]float64{} p := 0.0 for p \u003c 1 { tp := r.Float64() if p+tp \u003c= 1 { p += tp } else { tp = 1 - p p = 1 } arr := [_IFS_PARAM_NUM]float64{} arr[_IFS_PARAM_NUM-1] = tp for i := 0; i \u003c _IFS_PARAM_NUM-1; i++ { arr[i] = 2*r.Float64() - 1 } a = append(a, arr[:]) } return a } ","date":"2017-04-01","objectID":"/article/2017/04/01/ifs/:2:0","tags":["go","draw","fractal"],"title":"IFS","uri":"/article/2017/04/01/ifs/"},{"categories":["development"],"content":"欣赏 根据不同的参数可以生成不同的图像，以下为比较典型的一些3： IFS-Spiral IFS-Flourish 下面是随机生成的： 这张有些像宇宙星系！ {-0.889272, 0.656922, -0.927109, -0.322378, 0.856565, 0.478706, 0.937723}, {0.411268, -0.581772, 0.998787, -0.631693, -0.731553, 0.226007, 0.0622774}, IFS-Nebula 这张有些抽象。 {-0.872001, 0.0808141, 0.205013, 0.726129, -0.133041, -0.287383, 0.790841}, {0.148498, -0.880393, 0.901023, 0.567552, 0.99911, 0.760125, 0.209159}, IFS-Ball IFS分形艺术 ↩︎ 经典的分形算法：迭代函数系IFS ↩︎ IFS算法绘制图形 ↩︎ ","date":"2017-04-01","objectID":"/article/2017/04/01/ifs/:3:0","tags":["go","draw","fractal"],"title":"IFS","uri":"/article/2017/04/01/ifs/"},{"categories":["development"],"content":"牛顿迭代是求出多项式解的一种方法，也可以画出漂亮的分形图。 ","date":"2017-03-30","objectID":"/article/2017/03/30/newton-iter-fractal/:0:0","tags":["go","draw","fractal"],"title":"牛顿迭代分形","uri":"/article/2017/03/30/newton-iter-fractal/"},{"categories":["development"],"content":"牛顿迭代 过程就不写了，可查看注释，里面分析很清楚。1 公式： $$ z_{n+1}=z_n+\\frac{f(z_n)}{f’(z_n)} $$ 分形图则是根据以上公式在复平面上绘制的。 确定想要绘制数据范围，如 $z=a+bi,a\\in[-1,1],b\\in[-1,1]$ 将复平面数据映射在画布上，如 x 轴为实部（a），y 轴为虚部（b） 画布上每个点进行牛顿迭代，当 $|z_{n+1}-z_n| \u003c 0.001$，即迭代到多项式一个解，根据迭代次数和靠近的解设置该点的颜色2 ","date":"2017-03-30","objectID":"/article/2017/03/30/newton-iter-fractal/:1:0","tags":["go","draw","fractal"],"title":"牛顿迭代分形","uri":"/article/2017/03/30/newton-iter-fractal/"},{"categories":["development"],"content":"实现 刚发现 golang 语言原生支持复数运算，省了不少事。 以下以 $f(z)=z^2+1$ 多项式为例。 const ( _NEWTON_E = 0.001 _NEWTON_MAP_MAX = 3.0 ) func newton_f(z complex128) complex128 { f := z*z + 1 return f } func newton_df(z complex128) complex128 { df := 2 * z return df } func newton_iter(z complex128) int { for i := 0; i \u003c 255; i += 9 { z1 := z - newton_f(z)/newton_df(z) if cmplx.Abs(z1-z) \u003c _NEWTON_E { return i } z = z1 } return 255 } func newton(img *image.RGBA, limit int) { for i := 0; i \u003c limit; i++ { zx := _NEWTON_MAP_MAX*float64(i)/float64(limit) - _NEWTON_MAP_MAX/2 for j := 0; j \u003c limit; j++ { zy := _NEWTON_MAP_MAX*float64(j)/float64(limit) - _NEWTON_MAP_MAX/2 gray := uint8(newton_iter(complex(zx, zy))) point(img, i, j, color.Gray{gray}) } } } ","date":"2017-03-30","objectID":"/article/2017/03/30/newton-iter-fractal/:2:0","tags":["go","draw","fractal"],"title":"牛顿迭代分形","uri":"/article/2017/03/30/newton-iter-fractal/"},{"categories":["development"],"content":"测试 func Test_newton(t *testing.T) { const max_len = 500 img := image.NewRGBA(image.Rect(0, 0, max_len, max_len)) newton(img, max_len) f, _ := os.OpenFile(\"newton.png\", os.O_WRONLY|os.O_CREATE, 0600) defer f.Close() png.Encode(f, img) } 结果： result ","date":"2017-03-30","objectID":"/article/2017/03/30/newton-iter-fractal/:3:0","tags":["go","draw","fractal"],"title":"牛顿迭代分形","uri":"/article/2017/03/30/newton-iter-fractal/"},{"categories":["development"],"content":"分形欣赏 $f(z)=z^3-1$ result $f(z)=z^8+15z^4-16$ result $f(z)=z^7+iz-1$ result ","date":"2017-03-30","objectID":"/article/2017/03/30/newton-iter-fractal/:3:1","tags":["go","draw","fractal"],"title":"牛顿迭代分形","uri":"/article/2017/03/30/newton-iter-fractal/"},{"categories":["development"],"content":"无心插柳 开始我不知道 golang 自带复数运算，所以自己写了个错误的，结果生成了意想不到的图片，也挺好看的。 颇有水墨之风 (≖‿ゝ≖)✧ result result NEWTON’S METHOD AND FRACTALS ↩︎ 经典的分形算法：牛顿迭代 ↩︎ ","date":"2017-03-30","objectID":"/article/2017/03/30/newton-iter-fractal/:3:2","tags":["go","draw","fractal"],"title":"牛顿迭代分形","uri":"/article/2017/03/30/newton-iter-fractal/"},{"categories":["development"],"content":"曼德博集合（Mandelbrot set）复平面上点的集合，和朱利亚集有些相似。 下面使用 golang 语言绘制一个曼德博集图。 ","date":"2017-03-27","objectID":"/article/2017/03/27/mandelbrot-set/:0:0","tags":["go","draw","fractal"],"title":"Mandelbrot集","uri":"/article/2017/03/27/mandelbrot-set/"},{"categories":["development"],"content":"曼德博集1 曼德博集合可以用复二次多项式来定义：$f_c(z) = z^2 + c$，其中 $c$ 是一个复数参数。 从 $z = 0$ 开始对 $f_c(z)$ 进行迭代，形成以下序列： $$(0, f_c(0), f_c(f_c(0)), f_c(f_c(f_c(0))), \\ldots)$$ 不同的参数 $c$ 可能使序列的绝对值逐渐发散到无限大，也可能收敛在有限的区域内。 曼德博集合 $M$ 就是使序列不延伸至无限大的所有复数 $c$ 的集合。 ","date":"2017-03-27","objectID":"/article/2017/03/27/mandelbrot-set/:1:0","tags":["go","draw","fractal"],"title":"Mandelbrot集","uri":"/article/2017/03/27/mandelbrot-set/"},{"categories":["development"],"content":"理解 曼德博集多项式和朱利亚集一致，只是朱利亚集给定 $c$，求 $z$ 集，而曼德博是给定 $z = 0$，求 $c$ 集。 ","date":"2017-03-27","objectID":"/article/2017/03/27/mandelbrot-set/:1:1","tags":["go","draw","fractal"],"title":"Mandelbrot集","uri":"/article/2017/03/27/mandelbrot-set/"},{"categories":["development"],"content":"实现 func mandelbrot(img *image.RGBA, limit int) { // z = 0 zx := 0.0 zy := 0.0 for i := 0; i \u003c limit; i++ { cx := float64(3*i)/float64(limit) - 2 for j := 0; j \u003c limit; j++ { cy := float64(3*j)/float64(limit) - 1.5 gray := uint8(julia_divergent_grey(zx, zy, cx, cy)) point(img, i, j, color.Gray{gray}) } } } julia_divergent_grey 是上一篇中绘制灰度函数，不在此复述。 ","date":"2017-03-27","objectID":"/article/2017/03/27/mandelbrot-set/:2:0","tags":["go","draw","fractal"],"title":"Mandelbrot集","uri":"/article/2017/03/27/mandelbrot-set/"},{"categories":["development"],"content":"测试 func Test_mandelbrot(t *testing.T) { const max_len = 1000 img := image.NewRGBA(image.Rect(0, 0, max_len, max_len)) mandelbrot(img, max_len) f, _ := os.OpenFile(\"mandelbrot.png\", os.O_WRONLY|os.O_CREATE, 0600) defer f.Close() png.Encode(f, img) } 维基百科：曼德博集合 ↩︎ ","date":"2017-03-27","objectID":"/article/2017/03/27/mandelbrot-set/:3:0","tags":["go","draw","fractal"],"title":"Mandelbrot集","uri":"/article/2017/03/27/mandelbrot-set/"},{"categories":["development"],"content":"使用 golang 绘制一个朱利亚集合图像。 ","date":"2017-03-23","objectID":"/article/2017/03/23/julia-set/:0:0","tags":["go","draw","fractal"],"title":"Julia集","uri":"/article/2017/03/23/julia-set/"},{"categories":["development"],"content":"朱利亚集合 朱利亚集合（Julia Set）是在复平面上点的集合，所以可以使用二维平面绘制出来。 ","date":"2017-03-23","objectID":"/article/2017/03/23/julia-set/:1:0","tags":["go","draw","fractal"],"title":"Julia集","uri":"/article/2017/03/23/julia-set/"},{"categories":["development"],"content":"定义1 朱利亚集合可以由下式进行反复迭代得到： $$ f_c(z) = z^2 + c $$ 对于固定的复数 c，取某一 z 值（如 $z_0$），可以得到序列： $$ z_0, f_c(z_0), f_c(f_c(z_0)), f_c(f_c(f_c(z_0))), \\ldots $$ 这一序列可能发散于无穷大或始终处于某一范围之内并收敛于某一值。 我们将使其不扩散的 z 值的集合称为朱利亚集合。 ","date":"2017-03-23","objectID":"/article/2017/03/23/julia-set/:1:1","tags":["go","draw","fractal"],"title":"Julia集","uri":"/article/2017/03/23/julia-set/"},{"categories":["development"],"content":"理解 点的集合 满足 $f_c(z)$ 序列收敛的集合（之前我以为是序列的集合） 直观上使函数不发散的范围应该是： $$ \\begin{cases} z = a + bi \u0026 a,b=(-1,1)\\\\ c = d + ei \u0026 d,e=(-1,1) \\end{cases} $$ 判断点是否趋于收敛条件2是 $|z|\u003c2$ ","date":"2017-03-23","objectID":"/article/2017/03/23/julia-set/:1:2","tags":["go","draw","fractal"],"title":"Julia集","uri":"/article/2017/03/23/julia-set/"},{"categories":["development"],"content":"复数 ","date":"2017-03-23","objectID":"/article/2017/03/23/julia-set/:2:0","tags":["go","draw","fractal"],"title":"Julia集","uri":"/article/2017/03/23/julia-set/"},{"categories":["development"],"content":"运算法则3 加减法 $$ (a+bi)+(c+di)=(a+c)+(b+d)i \\\\ (a+bi)-(c+di)=(a-c)+(b-d)i $$ 乘除法 $$ (a+bi)(c+di)=(ac-bd)+(bc+ad)i \\\\ \\frac{a+bi}{c+di}=\\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i $$ ","date":"2017-03-23","objectID":"/article/2017/03/23/julia-set/:2:1","tags":["go","draw","fractal"],"title":"Julia集","uri":"/article/2017/03/23/julia-set/"},{"categories":["development"],"content":"理解 虚数 $i$ 可以理解为一个旋转量（逆时针 90 度）45 复数包含实部和虚部，也就是长度和旋转量，所以可以用二维平面表示5。 ","date":"2017-03-23","objectID":"/article/2017/03/23/julia-set/:2:2","tags":["go","draw","fractal"],"title":"Julia集","uri":"/article/2017/03/23/julia-set/"},{"categories":["development"],"content":"实现 根据复数乘法法则可得到 $f_c(z)$ 函数如下计算，返回新的 $z$ 值。 func julia_fc(zx, zy, cx, cy float64) (float64, float64) { z_x := zx*zx - zy*zy + cx z_y := 2*zx*zy + cy return z_x, z_y } 迭代 n 次保证 $z$ 值在一定范围内，迭代次数越多（收敛）则点的灰度越小（即暗），迭代次数越少（发散）则点的灰度越大（即亮）。 const ( _JULIA_R = 2.0 ) func julia_divergent_grey(zx, zy, cx, cy float64) int { for i := 255; i \u003e= 0; i -= 3 { zx, zy = julia_fc(zx, zy, cx, cy) if math.Sqrt(zx*zx+zy*zy) \u003e _JULIA_R { return i } } return 0 } 因为真实的图像坐标是正整数，而 Julia 集收敛坐标在 [-1,1] 之间，所以计算时需要进行一次坐标变换。 最终绘图函数如下，复数 $c$ 值为每次调用随机生成。 func julia(img *image.RGBA, limit int) { s := rand.NewSource(time.Now().Unix()) r := rand.New(s) // c = [0, 1] cx := r.Float64()*2 - 1 cy := r.Float64()*2 - 1 fmt.Println(cx, cy) for i := 0; i \u003c limit; i++ { zx := float64(4*i)/float64(limit) - _JULIA_R for j := 0; j \u003c limit; j++ { zy := float64(4*j)/float64(limit) - _JULIA_R gray := uint8(julia_divergent_grey(zx, zy, cx, cy)) point(img, i, j, color.Gray{gray}) } } } ","date":"2017-03-23","objectID":"/article/2017/03/23/julia-set/:3:0","tags":["go","draw","fractal"],"title":"Julia集","uri":"/article/2017/03/23/julia-set/"},{"categories":["development"],"content":"测试 func Test_julia(t *testing.T) { const r = 1000 img := image.NewRGBA(image.Rect(0, 0, r, r)) julia(img, r) f, _ := os.OpenFile(\"julia.png\", os.O_WRONLY|os.O_CREATE, 0600) defer f.Close() png.Encode(f, img) } 生成一些好看的图像： 朱利亚集合图像示例 1 朱利亚集合图像示例 2 朱利亚集合图像示例 3 朱利亚集合图像示例 4 朱利亚集合图像示例 5 朱利亚集合图像示例 6 朱利亚集合图像示例 7 朱利亚集合图像示例 8 停不下来了 …⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄…. 维基百科：朱利亚集合 ↩︎ 神奇的分形艺术（四）：Julia集和Mandelbrot集 ↩︎ 百度百科：复数运算法则 ↩︎ 虚数的意义 ↩︎ A Visual, Intuitive Guide to Imaginary Numbers ↩︎ ↩︎ ","date":"2017-03-23","objectID":"/article/2017/03/23/julia-set/:4:0","tags":["go","draw","fractal"],"title":"Julia集","uri":"/article/2017/03/23/julia-set/"},{"categories":["development"],"content":"使用 golang 绘制一个科赫曲线（Koch）雪花。 ","date":"2017-03-21","objectID":"/article/2017/03/21/koch/:0:0","tags":["go","draw","fractal"],"title":"Koch","uri":"/article/2017/03/21/koch/"},{"categories":["development"],"content":"科赫曲线 1 给定线段 AB，科赫曲线可以由以下步骤生成： 将线段分成三等份：AC，CD，DB 以 CD 为底，向外（内外随意）画一个等边三角形 DMC 将线段 CD 移除 分别对 AC，CM，MD，DB 重复 1~3。 科赫雪花是以等边三角形三边生成的科赫曲线组成的。 ","date":"2017-03-21","objectID":"/article/2017/03/21/koch/:1:0","tags":["go","draw","fractal"],"title":"Koch","uri":"/article/2017/03/21/koch/"},{"categories":["development"],"content":"等边三角形 想要完成该曲线的生成首先要解决一个几何问题，如何通过两点坐标求出等边三角形第三个顶点坐标，数学有很多种解法，可是如何变成代码呢？ 查到有人总结了一个万能公式2： 对于任意两个不同点 A 和 B，A 绕 B 逆时针旋转 θ 角度后 C 坐标为： $$ \\begin{cases} x = |x_A-x_B| \\times \\cosθ - |y_A-y_B| \\times \\sinθ + x_B \\\\ y = |y_A-y_B| \\times \\cosθ + |x_A-x_B| \\times \\sinθ + y_B \\end{cases} $$ 而等边三角形已知 θ 角为 60 度。 具体的推导过程请移步原博文。 ","date":"2017-03-21","objectID":"/article/2017/03/21/koch/:2:0","tags":["go","draw","fractal"],"title":"Koch","uri":"/article/2017/03/21/koch/"},{"categories":["development"],"content":"实现 下面是用 golang 实现的 Koch 函数，其中 line 为两点画一条直线，line_len 为计算直线的长度。 const ( _KOCH_LINE_MIN_LENGTH = 15 ) func koch_point(x1, y1, x2, y2 int) []image.Point { var pots [5]image.Point pots[0].X = x1 pots[0].Y = y1 pots[4].X = x2 pots[4].Y = y2 dx := float64(x2 - x1) dy := float64(y2 - y1) pots[1].X = x1 + int(dx/3) pots[1].Y = y1 + int(dy/3) pots[3].X = x2 - int(dx/3) pots[3].Y = y2 - int(dy/3) dx = float64(pots[3].X - pots[1].X) dy = float64(pots[3].Y - pots[1].Y) pots[2].X = int(dx*0.5-dy*0.8660254) + pots[1].X pots[2].Y = int(dy*0.5+dx*0.8660254) + pots[1].Y return pots[:] } func koch(img *image.RGBA, x1, y1, x2, y2 int, c color.Color) { p := koch_point(x1, y1, x2, y2) next := true for i := 0; i \u003c len(p)-1; i++ { if line_len(p[i].X, p[i].Y, p[i+1].X, p[i+1].Y) \u003c _KOCH_LINE_MIN_LENGTH { next = false } } for i := 0; i \u003c len(p)-1; i++ { if next { koch(img, p[i].X, p[i].Y, p[i+1].X, p[i+1].Y, c) } else { line(img, p[i].X, p[i].Y, p[i+1].X, p[i+1].Y, c) } } } ","date":"2017-03-21","objectID":"/article/2017/03/21/koch/:3:0","tags":["go","draw","fractal"],"title":"Koch","uri":"/article/2017/03/21/koch/"},{"categories":["development"],"content":"测试 绘制一片科赫雪花。 func Test_koch(t *testing.T) { img := image.NewRGBA(image.Rect(0, 0, 600, 600)) // 等边三角形 koch(img, 250, 0, 0, 433, color.RGBA{0, 0, 0, 255}) koch(img, 0, 433, 500, 433, color.RGBA{0, 0, 0, 255}) koch(img, 500, 433, 250, 0, color.RGBA{0, 0, 0, 255}) f, _ := os.OpenFile(\"koch.png\", os.O_WRONLY|os.O_CREATE, 0600) defer f.Close() png.Encode(f, img) } 维基百科-科赫曲线 ↩︎ 计算几何之向量旋转 ↩︎ ","date":"2017-03-21","objectID":"/article/2017/03/21/koch/:4:0","tags":["go","draw","fractal"],"title":"Koch","uri":"/article/2017/03/21/koch/"},{"categories":["development"],"content":"golang 自带一些图片相关库，但是没有找到画一条直线的函数，网上查找了一番，将结果记录于此。 ","date":"2017-03-20","objectID":"/article/2017/03/20/draw-line/:0:0","tags":["go","draw"],"title":"画线","uri":"/article/2017/03/20/draw-line/"},{"categories":["development"],"content":"坐标系 -----→ x | | ↓ y 水平为 x 轴，正方向向右；垂直为 y 轴，正方向向下。 ","date":"2017-03-20","objectID":"/article/2017/03/20/draw-line/:1:0","tags":["go","draw"],"title":"画线","uri":"/article/2017/03/20/draw-line/"},{"categories":["development"],"content":"画一条直线 难点为斜线，需要临近的像素点近似为一条直线。 func line(img *image.RGBA, x1, y1, x2, y2 int, c color.Color) { delta_x := x2 - x1 delta_y := y2 - y1 if delta_x == 0 \u0026\u0026 delta_y == 0 { img.Set(x1, y1, c) return } abs_delta_x := math.Abs(float64(delta_x)) abs_delta_y := math.Abs(float64(delta_y)) x := float64(x1) y := float64(y1) if abs_delta_y \u003e abs_delta_x { dx := float64(delta_x) / abs_delta_y dy := float64(delta_y) / abs_delta_y for i := 0; i \u003c= int(abs_delta_y); i++ { img.Set(int(x+0.5), int(y), c) x += dx y += dy } } else { dx := float64(delta_x) / abs_delta_x dy := float64(delta_y) / abs_delta_x for i := 0; i \u003c= int(abs_delta_x); i++ { img.Set(int(x), int(y+0.5), c) x += dx y += dy } } } ","date":"2017-03-20","objectID":"/article/2017/03/20/draw-line/:2:0","tags":["go","draw"],"title":"画线","uri":"/article/2017/03/20/draw-line/"},{"categories":["development"],"content":"测试 在中心为起始点向 360 度方向发散画线，查看最后图像是否满意。 func Test_line(t *testing.T) { img := image.NewRGBA(image.Rect(0, 0, _WIDTH, _HIGH)) cs := []color.RGBA{ {255, 0, 0, 255}, {255, 255, 0, 255}, {0, 255, 0, 255}, {0, 255, 255, 255}, {0, 0, 255, 255}, {255, 0, 255, 255}, } x0 := _WIDTH / 2 y0 := _HIGH / 2 cs_i := 0 for i := 0; i \u003c _WIDTH; i += 7 { x := i y := 0 cs_i++ line(img, x, y, x0, y0, cs[cs_i%len(cs)]) } for i := 0; i \u003c _HIGH; i += 8 { x := _WIDTH y := i cs_i++ line(img, x, y, x0, y0, cs[cs_i%len(cs)]) } for i := _WIDTH; i \u003e= 0; i -= 10 { x := i y := _HIGH cs_i++ line(img, x, y, x0, y0, cs[cs_i%len(cs)]) } for i := _HIGH; i \u003e= 0; i -= 10 { x := 0 y := i cs_i++ line(img, x, y, x0, y0, cs[cs_i%len(cs)]) } // Save to line.png f, _ := os.OpenFile(\"line.png\", os.O_WRONLY|os.O_CREATE, 0600) defer f.Close() png.Encode(f, img) } ","date":"2017-03-20","objectID":"/article/2017/03/20/draw-line/:3:0","tags":["go","draw"],"title":"画线","uri":"/article/2017/03/20/draw-line/"},{"categories":["thoughts"],"content":"复杂系统建模","date":"2017-03-01","objectID":"/article/2017/03/01/complex-system-modeling/","tags":["book"],"title":"复杂系统建模","uri":"/article/2017/03/01/complex-system-modeling/"},{"categories":["thoughts"],"content":"最近准备把留存没看过的书整理一下，断舍离嘛，首先看的是这本《复杂系统建模与仿真》，看得比较糙，记录笔记如下。 ","date":"2017-03-01","objectID":"/article/2017/03/01/complex-system-modeling/:0:0","tags":["book"],"title":"复杂系统建模","uri":"/article/2017/03/01/complex-system-modeling/"},{"categories":["thoughts"],"content":"引论 人类认识世界的过程，就是不断地建立世界模型的过程，所有的描述世界的知识，都是在对世界建模。 从建模来了解、解释以及预测世界。 而我们的人生则是需要不断的修正自己对这个世界的模型。 ","date":"2017-03-01","objectID":"/article/2017/03/01/complex-system-modeling/:1:0","tags":["book"],"title":"复杂系统建模","uri":"/article/2017/03/01/complex-system-modeling/"},{"categories":["thoughts"],"content":"理论基础 CAS 理论即复杂适应系统（Complex Adaptive System）。 ","date":"2017-03-01","objectID":"/article/2017/03/01/complex-system-modeling/:2:0","tags":["book"],"title":"复杂系统建模","uri":"/article/2017/03/01/complex-system-modeling/"},{"categories":["thoughts"],"content":"基本思想 适应性造就复杂性。 适应性就是指它能够与环境以及其他主体进行交流，在这种交流的过程中「学习」或「积累经验」，并且根据学到的经验改变自身的结构和行为方式。 ","date":"2017-03-01","objectID":"/article/2017/03/01/complex-system-modeling/:2:1","tags":["book"],"title":"复杂系统建模","uri":"/article/2017/03/01/complex-system-modeling/"},{"categories":["thoughts"],"content":"基本概念 聚集（Aggregation） 即把相似的事物聚合成类，识别出能使简单体形成具有高度适应性的聚集体的机制。 标识（Tag） 标识的作用在于促进主体选择性的相互作用。 非线性（Non-linearity） 流（Flow） 物质流、能量流和信息流。 多样性（Diversity） 内部模型（Internal Model） 积木块（Building Blocks） ","date":"2017-03-01","objectID":"/article/2017/03/01/complex-system-modeling/:2:2","tags":["book"],"title":"复杂系统建模","uri":"/article/2017/03/01/complex-system-modeling/"},{"categories":["thoughts"],"content":"多主体模型 多主体系统解决问题的方法是把问题分解为多个程序片段或主体，每个程序片段或主体拥有各自独立的知识或专业经验，通过联合或群集的方式，一群主体能够找到比单个主体更优的解决策略。 现实世界是复杂的，而反映复杂现实世界的模型却大可不必也复杂。 例子：康威「生命游戏」和 Boid 模型。 涌现：当低层次单元间交互导致高一层次新的现象发生时，我们称之为涌现。 ","date":"2017-03-01","objectID":"/article/2017/03/01/complex-system-modeling/:3:0","tags":["book"],"title":"复杂系统建模","uri":"/article/2017/03/01/complex-system-modeling/"},{"categories":["thoughts"],"content":"书摘 创新意味着改变原有的惯例，创新使创新者有较大的优势，从而获得较多的利润。但这种情况只能是暂时的，非创新者也可以进行创新或模仿，后来者可逐渐赶上先进者，先进者会逐渐失去自己的优势。 所有的学习算法都离不开评价与赏罚的机制。 ","date":"2017-03-01","objectID":"/article/2017/03/01/complex-system-modeling/:4:0","tags":["book"],"title":"复杂系统建模","uri":"/article/2017/03/01/complex-system-modeling/"},{"categories":["thoughts"],"content":"时间管理相关","date":"2017-02-20","objectID":"/article/2017/02/20/time-manage/","tags":["book"],"title":"时间管理","uri":"/article/2017/02/20/time-manage/"},{"categories":["thoughts"],"content":"自制力一直比较差，拖延症也是时时发作，把看到的一些应对之策记录如下。 ","date":"2017-02-20","objectID":"/article/2017/02/20/time-manage/:0:0","tags":["book"],"title":"时间管理","uri":"/article/2017/02/20/time-manage/"},{"categories":["thoughts"],"content":"真正想要的生活 这是 TED 一期名为《如何掌控你的自由时间》的演讲，其中主要的思想，时间不是挤出来的，而是要把时间真正用在你想用的地方上，你说没有时间其实只是你觉得这件事不重要罢了。 所以没有分清主次也许是关键所在，真正想要去做的事首先分配时间，其他的琐事自会挤出来完成。 ","date":"2017-02-20","objectID":"/article/2017/02/20/time-manage/:1:0","tags":["book"],"title":"时间管理","uri":"/article/2017/02/20/time-manage/"},{"categories":["thoughts"],"content":"设置 deadline 这是 TED 一期《你有拖延症吗?》的演讲，演讲者很诙谐幽默。 其中主要控制拖延症的方法就是给自己的任务设置一个 dealine 日期，尤其是一些没有目标的任务，比如我要健身/看书/学英语，这些看似比较模糊又没有完成日期的任务，最容易一拖再拖。 ","date":"2017-02-20","objectID":"/article/2017/02/20/time-manage/:2:0","tags":["book"],"title":"时间管理","uri":"/article/2017/02/20/time-manage/"},{"categories":["thoughts"],"content":"行动 还是 TED 《你有拖延症吗? 续篇》，其实感觉不是典型的拖延症，这应该算是深思熟虑过头的人吧。 有了想法立即行动，在过程中不断纠错，其实也挺像敏捷开发？ ","date":"2017-02-20","objectID":"/article/2017/02/20/time-manage/:3:0","tags":["book"],"title":"时间管理","uri":"/article/2017/02/20/time-manage/"},{"categories":["thoughts"],"content":"扩展阅读 ","date":"2017-02-20","objectID":"/article/2017/02/20/time-manage/:4:0","tags":["book"],"title":"时间管理","uri":"/article/2017/02/20/time-manage/"},{"categories":["thoughts"],"content":"超级时间整理术 迈克尔•赫佩尔 (Michael Heppell) 推荐指数 3 星，概览一遍，以下几点可以适用。 类似断舍离，减少找东西的时间，保持桌面整洁 每天晚上列出明天必做的 5 件事（只做重要的事，貌似和第一个演讲不谋而合） ","date":"2017-02-20","objectID":"/article/2017/02/20/time-manage/:4:1","tags":["book"],"title":"时间管理","uri":"/article/2017/02/20/time-manage/"},{"categories":["thoughts"],"content":"意志力 [美] 罗伊·鲍迈斯特 / [美] 约翰·蒂尔尼 推荐指数 5 星，挺清晰的解释了什么是意志力，如何消耗/恢复等，看完后就会知道之前看得如何不拖延的技巧为何有效，可以算是理论基础了吧。 意志力下降可以吃些东西（糖不推荐） 一次只做一件事 保持良好的小习惯对意志力是有好处的（每天刷牙） 意志力是消耗品，且用且珍惜 ","date":"2017-02-20","objectID":"/article/2017/02/20/time-manage/:4:2","tags":["book"],"title":"时间管理","uri":"/article/2017/02/20/time-manage/"},{"categories":["thoughts"],"content":"总结 看了很多东西，现在自己使用的方法，希望可以见效。 制定目标 想要过的生活/成为的人，算是指路灯塔一般的存在吧 细化目标 以年为单位，年底总结完成情况 目标要细化为每天/每周多长时间完成什么，比如每天半小时看书 截止日期 任务目标要在明确日期内完成 短时间任务，可以使用手机设个闹钟，防止频繁查看时间分神（番茄工作法） 奖励机制 让欲望驱动自己行动 可将完成情况转化为可统计数字，我是算出当前每小时价格（工资计算），各任务分配系数乘以耗时则可算出相应价格，然后就用这些钱（买买买）奖励自己吧（当然还是比较主观，需要自律） 接受拖延 如果没有完成任务，不可自暴自弃，要接受自己不完美，然后再次行动 细想地球存在的四十几亿年，人类文明史不过七八千年，而一个人的生命又不过百年，对于地球来说人类的生命真可以说朝生暮死须臾之间罢了，然而能活到百岁的能有几人，能做自己想做的事又有几年，四肢灵活有几年，头脑清醒又有几年，细想真的没有多少时间了啊。 ","date":"2017-02-20","objectID":"/article/2017/02/20/time-manage/:5:0","tags":["book"],"title":"时间管理","uri":"/article/2017/02/20/time-manage/"},{"categories":["system"],"content":"程序员经常会使用脚本来方便自己的开发，不过本人脑子记性不好，在此记录一些经常使用的模板。 ","date":"2016-11-30","objectID":"/article/2016/11/30/bash-script/:0:0","tags":["bash","expect"],"title":"脚本","uri":"/article/2016/11/30/bash-script/"},{"categories":["system"],"content":"bash ","date":"2016-11-30","objectID":"/article/2016/11/30/bash-script/:1:0","tags":["bash","expect"],"title":"脚本","uri":"/article/2016/11/30/bash-script/"},{"categories":["system"],"content":"文本处理 逐行读取文件 FILE=/home/user/file.txt cat $FILE | while read line do echo \"line: $line\" done Json 数据解析 先下载了一个工具：jq echo \"{\\\"firstName\\\": \\\"John\\\",\\\"lastName\\\": \\\"Smith\\\"}\" | jq '.firstName' 数据计算 浮点除法需要设置小数点位数 echo \"scale=10; 89.0 / 1000\" | bc 数据比较 V=-120.12 echo \"$V \u003c -180.0\" | bc 时间转换 ts -\u003e time date -d @12313 +\"%F %T\" ","date":"2016-11-30","objectID":"/article/2016/11/30/bash-script/:1:1","tags":["bash","expect"],"title":"脚本","uri":"/article/2016/11/30/bash-script/"},{"categories":["system"],"content":"控制输入 输入参数 if [ -z $1 ]; then echo $\"Usage: $0 in\" exit 1 fi echo \"in: $1\" 等待输入参数： if read -t 10 -p \"wait input: \" indata ## 10 秒超时 then echo \"input：$indata\" else echo \"timeout\" fi 判断权限 if [[ $EUID -ne 0 ]]; then echo Only root can access run exit 1 fi 命令选择 rc=0 case \"$1\" in hello) echo \"hello world\" ;; *) echo $\"Usage: $0 {hello}\" exit 2 esac exit $rc 判断运行结果 do_or_die() { eval $* || exit $? } do_or_die echo \"Hello\" 多次尝试 RET=0 result() { eval $* RET=$? } loop() { n=0 until [ $n -ge 3 ] do echo \"TRY IT $n TIMES ...\" result $* if [ $RET == 0 ]; then break fi echo \"RET IS $RET ...\" n=$[$n+1] done } ","date":"2016-11-30","objectID":"/article/2016/11/30/bash-script/:1:2","tags":["bash","expect"],"title":"脚本","uri":"/article/2016/11/30/bash-script/"},{"categories":["system"],"content":"expect 交互式脚本常用，调试可加上 -d 参数定位问题原因 ","date":"2016-11-30","objectID":"/article/2016/11/30/bash-script/:2:0","tags":["bash","expect"],"title":"脚本","uri":"/article/2016/11/30/bash-script/"},{"categories":["system"],"content":"常用 函数 proc func_name { argc } { puts $argc } func_name \"hello\" 如果多个函数公用一个 spawn 怎么办？ 一种是使用 upvar spawn_id 引入全局变量1： proc expect_prompt {} { upvar spawn_id spawn_id expect -re {bash-[.0-9]+[#$] $} } proc open_conn {} { upvar spawn_id spawn_id spawn bash --noprofile --norc expect_prompt } proc close_conn {} { upvar spawn_id spawn_id send \"exit\\r\" expect eof } proc send_cmd { cmd } { upvar spawn_id spawn_id send \"$cmd\\r\" expect_prompt } proc main {} { open_conn send_cmd \"echo spawn_id=$spawn_id\" send_cmd \"ps Tu\" close_conn } main 另一种是函数只对 expect 结果进行处理： proc func {} { expect { \"xx\" { return 0 } } return 1 } spawn xx if {[func]} { puts \"ERROR\" exit 1 } expect eof exit 0 循环 for {set i 0} {$i \u003c 5} {incr i} { puts \"$i\" } 判断 if { true } { puts \"true\" } else { puts \"false\" } interact2 在结尾加上 interact 表示把控制权交给用户 ","date":"2016-11-30","objectID":"/article/2016/11/30/bash-script/:2:1","tags":["bash","expect"],"title":"脚本","uri":"/article/2016/11/30/bash-script/"},{"categories":["system"],"content":"在 shell 脚本中引用 WORD=\"hello\" expect \u003c\u003c-EOF set timeout 10 puts $WORD puts \\$timeout expect eof EOF 注意变量和一些特殊字符转义问题 ","date":"2016-11-30","objectID":"/article/2016/11/30/bash-script/:2:2","tags":["bash","expect"],"title":"脚本","uri":"/article/2016/11/30/bash-script/"},{"categories":["system"],"content":"两步验证3 需要安装 oathtool spawn ssh $USER@$IP expect { \"(yes/no)?\" { send \"yes\\r\"; exp_continue } \"Verification code:\" { set verifi_code [exec oathtool --totp -b -d 6 $SECRETE_KEY] send \"\\$verifi_code\\r\"; exp_continue } \"password:\" { send \"$PASSWD\\r\" } timeout { exit 127 } } expect eof catch wait result exit [lindex \\$result 3] ","date":"2016-11-30","objectID":"/article/2016/11/30/bash-script/:2:3","tags":["bash","expect"],"title":"脚本","uri":"/article/2016/11/30/bash-script/"},{"categories":["system"],"content":"获取输入参数4 set user [lindex $argv 0] set ip [lindex $argv 1] set len [llength $argv] 如何在TCL Expect中的多个过程之间共享衍生的SSH过程 ↩︎ 使用expect的自动化交互 ↩︎ 使用expect实现自动2步登录 ↩︎ expect实现交互初步 ↩︎ ","date":"2016-11-30","objectID":"/article/2016/11/30/bash-script/:2:4","tags":["bash","expect"],"title":"脚本","uri":"/article/2016/11/30/bash-script/"},{"categories":["system"],"content":"共享内存","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"共享内存可以被描述成内存一个区域（段）的映射，这个区域可以被更多的进程所共享。1 该方式应该是 SysV IPC 中最快速度形式，减少了不必要的复制拷贝操作，但是 Linux 对共享内存不提供同步操作，一般需要其他方式进行辅助，如信号量。 ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:0:0","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"流程 一般流程2如下： 通过 ftok 获得确定的 IPC Key 使用 shmget 获得用于共享内存的特定 IPC ID 使用 shmat/shmdt 操作共享内存 使用 shmctl 移除共享内存 ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:1:0","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"函数 ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:2:0","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"shmget 建立/获得共享内存 #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e int shmget(key_t key, size_t size, int shmflg) key：键值，一般使用 ftok 获得 size：字节单位，申请的共享内存大小 shmflg：使用 | 连接 权限：可使用 0666 等表示，也可使用 open 中 mode 宏 IPC_CREAT：若不存在则创建 IPC_EXCL：若存在则返回错误（和 IPC_CREAT 一起使用） return：-1，错误；非负数，共享内存 ID 注： 查看系统共享内存可通过 ipcs -m 命令 查看系统对共享内存限制通过 ipcs -lm 命令 ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:2:1","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"shmctl 控制共享内存，设置、获取、删除。 #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e int shmctl(int shmid, int cmd, struct shmid_ds *buf) shmid：shmget 获得 ID cmd：同信号量类似，以下列出已尝试部分 IPC_RMID：命令实际上不从内核删除一个段，而是仅仅把这个段标记为删除，实际的删除发生在最后一个进程离开这个共享段时。3 buf： return：-1，错误 注： 删除系统中存在的共享内存可使用 ipcrm -m/M ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:2:2","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"shmat/shmdt 连接共享内存。 #include \u003csys/types.h\u003e #include \u003csys/shm.h\u003e void *shmat(int shmid, const void *shmaddr, int shmflg) shmid：shmget 获得 ID shmaddr：NULL，表示由系统分配 shmflg：标志 SHM_RDONLY：只读模式 return：-1，错误，共享内存起始地址 断开共享内存。 int shmdt(const void *shmaddr) shmaddr：共享内存其实地址 return：-1，错误 ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:2:3","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"实例 所有例子源码文件在 demo/c/ipc/shm/ 中。 ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:3:0","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"未同步 没有添加其他辅助手段多进程读写共享内存，会发生读取错误的可能。 以下例子共享内存使用字符串，因为对字符串的复制拷贝，一般不会是原子操作。 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/types.h\u003e #include \u003csys/shm.h\u003e #include \u003cerrno.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #define SHM_TEST_DATALEN 256 struct shm_test_st { char dat[SHM_TEST_DATALEN]; }; const char g_test_data[][SHM_TEST_DATALEN] = { {\"Nothing gold can stay\"}, {\"Nature's first green is gold\"}, {\"Her hardest hue to hold\"}, {\"Her early leaf's a flower\"}, {\"But only so an hour\"}, {\"Then leaf subsides leaf\"}, {\"So Eden sank to grief\"}, {\"So down gose down to day\"}, {\"Ending\"} }; int shm_write(struct shm_test_st *pdata) { int num = sizeof(g_test_data) / sizeof(g_test_data[0]); int i; for (i = 0; i \u003c num; i++) { strcpy(pdata-\u003edat, g_test_data[i]); printf(\"Write - %s\\n\", g_test_data[i]); sleep(1); } printf(\"Write Over!\\n\"); return 0; } int shm_read(struct shm_test_st *pdata) { sleep(1); char tmp[SHM_TEST_DATALEN]; while (1) { strcpy(tmp, pdata-\u003edat); int num = sizeof(g_test_data) / sizeof(g_test_data[0]); int ret = -1; int i; for (i = 0; i \u003c num; i++) { if (strcmp(tmp, g_test_data[i]) == 0) { ret = 0; if (i == (num - 1)) { printf(\"Read Over\\n\"); return 0; } } } if (ret \u003c 0) { printf(\"Read Error - %s\\n\", tmp); } sleep(0); } return -1; } int main (int argc, char **argv) { if (argc \u003c 2) { printf(\"demo w/r\\n\"); exit(1); } key_t ipckey = ftok(\"/tmp/test\", ':'); int shmid = shmget(ipckey, sizeof(struct shm_test_st), 0600 | IPC_CREAT); if (shmid \u003c 0) { printf(\"Error - %s\\n\", strerror(errno)); exit(1); } void *addr = NULL; if (argv[1][0] == 'w') { addr = shmat(shmid, NULL, 0); } else { // r addr = shmat(shmid, NULL, SHM_RDONLY); } if (addr == (void *)-1) { printf(\"Addr Error - %s\\n\", strerror(errno)); exit(1); } struct shm_test_st *p_shared = (struct shm_test_st *)addr; int ret; if (argv[1][0] == 'w') { ret = shm_write(p_shared); } else { // r ret = shm_read(p_shared); } if (shmctl(shmid, IPC_RMID, NULL) \u003c 0) { printf(\"Delete Error - %s\\n\", strerror(errno)); } if (ret \u003c 0) { exit(1); } } 执行程序： ./demo w \u0026 ./demo r \u0026 ./demo r \u0026 ./demo r \u0026 执行结果：可能产生读取信息错误，如下 Write - Nothing gold can stay Write - Nature's first green is gold Write - Her hardest hue to hold Read Error - Nature's first gto hold Write - Her early leaf's a flower Write - But only so an hour Write - Then leaf subsides leaf Read Error - But only so an hes llower Write - So Eden sank to grief Write - So down gose down to day Write - Ending Read Over Read Over Read Over Write Over! ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:3:1","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"写优先锁 上个例子中出现问题，很多是在写的过程中读取数据造成错误，查看网上一篇文章「知识讲解Unix操作系统共享内存」中说： 常规的方法是设一个信号量，Unix 操作系统将访问共享内存的程序作为临界区来处理。程序进入时用 p() 操作取得锁，退出时用 v() 操作释放锁。 只有 Server 进行 p()、v() 操作，信号量初始值设为 0，p() 操作将它加一，v() 操作将它减一；Client 读共享内存之前要先等待信号量的值为 0，这样 Server 的 p() 操作总是成功，而 Server 的 p() 操作后，尚未进入临界区的 Client 只能等到 Server 执行 v() 操作后才能读。这样 Server 比 Client 优先，Client 之间不互斥。4 当然以上方法其实只适合读很快速（原子）类型，本例应该还会有发生错误的可能，下面验证一下。 int shm_write(struct shm_test_st *pdata, int semid) { struct sembuf sem[1]; sem[0].sem_num = 0; sem[0].sem_flg = SEM_UNDO; int num = sizeof(g_test_data) / sizeof(g_test_data[0]); int i; for (i = 0; i \u003c num; i++) { sem[0].sem_op = 1; semop(semid, sem, 1); // p() printf(\"Write - %s\\n\", g_test_data[i]); strcpy(pdata-\u003edat, g_test_data[i]); sem[0].sem_op = -1; semop(semid, sem, 1); // v() sleep(1); } printf(\"Write Over!\\n\"); return 0; } int shm_read(struct shm_test_st *pdata, int semid) { struct sembuf sem[1]; sem[0].sem_num = 0; sem[0].sem_flg = SEM_UNDO; sleep(1); char tmp[SHM_TEST_DATALEN]; while (1) { sem[0].sem_op = 0; semop(semid, sem, 1); // wait() strcpy(tmp, pdata-\u003edat); int num = sizeof(g_test_data) / sizeof(g_test_data[0]); int ret = -1; int i; for (i = 0; i \u003c num; i++) { if (strcmp(tmp, g_test_data[i]) == 0) { ret = 0; if (i == (num - 1)) { printf(\"Read Over\\n\"); return 0; } } } if (ret \u003c 0) { printf(\"Read Error - %s\\n\", tmp); } sleep(0); } return -1; } 执行程序： ./demo w \u0026 ./demo r \u0026 ./demo r \u0026 ./demo r \u0026 执行结果：确实还是会产生错误 Write - Nothing gold can stay Write - Nature's first green is gold Read Error - Nothing gold canreen i Write - Her hardest hue to hold Write - Her early leaf's a flower Write - But only so an hour Write - Then leaf subsides leaf Write - So Eden sank to grief Write - So down gose down to day Write - Ending Read Over Read Over Read Over Write Over! ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:3:2","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"互斥锁 看来上面的方法也不行，那么只有读写全部加锁才能保证不出错了，不过这样的缺点就是所有的读也变成了串行，降低了效率。 int shm_write(struct shm_test_st *pdata, int semid) { struct sembuf sem[2]; sem[0].sem_num = 0; sem[1].sem_num = 0; sem[0].sem_flg = SEM_UNDO; sem[1].sem_flg = SEM_UNDO; int num = sizeof(g_test_data) / sizeof(g_test_data[0]); int i; for (i = 0; i \u003c num; i++) { sem[0].sem_op = 0; sem[1].sem_op = 1; semop(semid, sem, 2); printf(\"Write - %s\\n\", g_test_data[i]); strcpy(pdata-\u003edat, g_test_data[i]); sem[0].sem_op = -1; semop(semid, sem, 1); sleep(1); } printf(\"Write Over!\\n\"); return 0; } int shm_read(struct shm_test_st *pdata, int semid) { struct sembuf sem[2]; sem[0].sem_num = 0; sem[1].sem_num = 0; sem[0].sem_flg = SEM_UNDO; sem[1].sem_flg = SEM_UNDO; sleep(1); char tmp[SHM_TEST_DATALEN]; while (1) { sem[0].sem_op = 0; sem[1].sem_op = 1; semop(semid, sem, 2); strcpy(tmp, pdata-\u003edat); sem[0].sem_op = -1; semop(semid, sem, 1); int num = sizeof(g_test_data) / sizeof(g_test_data[0]); int ret = -1; int i; for (i = 0; i \u003c num; i++) { if (strcmp(tmp, g_test_data[i]) == 0) { ret = 0; if (i == (num - 1)) { printf(\"Read Over\\n\"); return 0; } } } if (ret \u003c 0) { printf(\"Read Error - %s\\n\", tmp); } sleep(0); } return -1; } 结果不会出现读错的情况了。 ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:3:3","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"读写锁 通过「Linux线程同步之读写锁（rwlock）」文章，发现信号量可以实现读写锁。 只要没有写模式下的加锁，任意线程都可以进行读模式下的加锁； 只有读写锁处于不加锁状态时，才能进行写模式下的加锁；5 将之前单锁变成双锁即可，一个表示写，一个表示读。 此方式适合少写多读的场景。 int shm_write(struct shm_test_st *pdata, int semid) { struct sembuf sem[3]; sem[0].sem_num = 0; // w sem[1].sem_num = 1; // r sem[2].sem_num = 0; // w sem[0].sem_flg = SEM_UNDO; sem[1].sem_flg = SEM_UNDO; sem[2].sem_flg = SEM_UNDO; int num = sizeof(g_test_data) / sizeof(g_test_data[0]); int i; for (i = 0; i \u003c num; i++) { sem[0].sem_op = 0; // wait write free sem[1].sem_op = 0; // wait read free sem[2].sem_op = 1; // write +1 -\u003e going semop(semid, sem, 3); printf(\"Write - %s\\n\", g_test_data[i]); strcpy(pdata-\u003edat, g_test_data[i]); sem[0].sem_op = -1; semop(semid, sem, 1); // write -1 -\u003e over sleep(1); } printf(\"Write Over!\\n\"); return 0; } int shm_read(struct shm_test_st *pdata, int semid) { struct sembuf sem[2]; sem[0].sem_num = 0; // w sem[1].sem_num = 1; // r sem[0].sem_flg = SEM_UNDO; sem[1].sem_flg = SEM_UNDO; sleep(1); char tmp[SHM_TEST_DATALEN]; while (1) { sem[0].sem_op = 0; // write is free sem[1].sem_op = 1; // read +1 -\u003e going semop(semid, sem, 2); strcpy(tmp, pdata-\u003edat); sem[0].sem_num = 1; // r sem[0].sem_op = -1; // read -1 -\u003e over semop(semid, sem, 1); int num = sizeof(g_test_data) / sizeof(g_test_data[0]); int ret = -1; int i; for (i = 0; i \u003c num; i++) { if (strcmp(tmp, g_test_data[i]) == 0) { ret = 0; if (i == (num - 1)) { printf(\"Read Over\\n\"); return 0; } } } if (ret \u003c 0) { printf(\"Read Error - %s\\n\", tmp); } sleep(0); } return -1; } 深入分析Linux内核源代码,7.3.3 ↩︎ 使用 UNIX System V IPC 机制共享应用程序数据 ↩︎ 深入分析Linux内核源代码,7.3.3,P288 ↩︎ 知识讲解Unix操作系统共享内存 ↩︎ Linux线程同步之读写锁（rwlock） ↩︎ ","date":"2016-09-05","objectID":"/article/2016/09/05/ipc-shm/:3:4","tags":["ipc","sysv"],"title":"共享内存","uri":"/article/2016/09/05/ipc-shm/"},{"categories":["system"],"content":"信号量及信号量上的操作","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"信号量及信号量上的操作是 E.W.Dijkstra 在 1965 年提出的一种解决同步、互斥问题的较通用的方法，并在很多操作系统中得以实现，Linux 改进并实现了这种机制。1 ","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/:0:0","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"流程 一般流程2如下： 通过 ftok 获得确定的 IPC Key 使用 semget 获得用于信号量的特定 IPC ID 使用 semop 操作信号量 使用 semctl 移除信号量 ","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/:1:0","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"函数 ","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/:2:0","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"semget 建立/获得信号量。 #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/sem.h\u003e int semget(key_t key, int nsems, int semflg) key：键值，一般使用 ftok 获得 nsems：在新创建的集合中信号量的个数，最大值 250。3 semflg：使用 | 连接 权限：可使用 0666 等表示，也可使用 open 中 mode 宏 IPC_CREAT：若不存在则创建 IPC_EXCL：若存在则返回错误（和 IPC_CREAT 一起使用） return：-1，错误；非负数，信号量 ID 注： 系统中查看存在的信号量可通过 ipcs -s 命令 最大值可通过 ipcs -ls 查看「max semaphores per array」，echo \"256 32000 32 128\" \u003e /proc/sys/kernel/sem 修改 4 ","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/:2:1","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"semctl 控制信号量集合，设置、获取、删除。 #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/sem.h\u003e int semctl(int semid, int semnum, int cmd, ...) semid：semget 获得 ID semnum：集合中哪个信号量，从 0 开始 cmd：常用如下5 IPC_STAT：从信号量集合上检索 semid_ds 结构，并存到 semun 联合体参数的成员 buf 的地址中 IPC_SET：设置一个信号量集合的 semid_ds 结构中 ipc_perm 域的值，并从 semun 的 buf 中取出值 IPC_RMID：移除信号量集合 GETALL：从信号量集合中获得所有信号量的值，并把其整数值存到 semun 联合体成员的一个指针数组中 GETNCNT：返回当前等待资源的进程个数 GETPID：返回最后一个执行系统调用 semop 进程的 PID GETVAL：返回信号量集合内单个信号量的值 GETZCNT：返回当前等待 100% 资源利用的进程个数 SETALL：与 GETALL 正好相反 SETVAL：用联合体中 val 成员的值设置信号量集合中单个信号量的值 args：union semun return：-1，错误 注： 系统中存在的信号量可通过 ipcrm -s/S 删除 ","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/:2:2","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"semop/semtimedop #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/sem.h\u003e int semop(int semid, struct sembuf *sops, unsigned nsops) int semtimedop(int semid, struct sembuf *sops, unsigned nsops, struct timespec *timeout) semid：semget 获得 ID sops：数组，结构如下 struct sembuf { unsigned short sem_num; /* 信号量集合索引 */ short sem_op; /* 操作数 */ short sem_flg; /* 操作标识 */ } sem_op： 零：如果 semval 为 0，则进行下一步，如果 semval 不为 0，则等待（IPC_NOWAIT 跳过） 正数：信号量的值加上该值 负数：semval 大于等于该值绝对值则相加，semval 小于该值绝对值则等待 sem_flag： IPC_NOWAIT：非阻塞 SEM_UNDO：进程退出自动解锁信号量，防止死锁 nsops：执行数组操作个数 理解： 保护资源时，可以用 sem=0 时表示空闲；那么加锁动作即 [0,1]，等待 sem 空闲并加一；解锁动作 [-1]，sem 减一返回空闲状态。 同步或生产消费问题，可以用 sem 加减表示，sem 加一表示生产一件或该操作完成可以进行下一步，消费方则等待减一 sem 又回到 0 状态。 ","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/:2:3","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"实例 ","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/:3:0","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"互斥锁 使用信号量来保护关键部分6 #include \u003csys/types.h\u003e #include \u003csys/sem.h\u003e #include \u003csys/ipc.h\u003e #include \u003cstring.h\u003e /* For strerror(3c) */ #include \u003cerrno.h\u003e /* For errno */ #include \u003cunistd.h\u003e /* rand(3c) */ #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main (int argc, char **argv) { key_t ipckey; int semid; struct sembuf sem[2]; /* sembuf defined in sys/sem.h */ /* Generate the ipc key */ ipckey = ftok(\"main.c\", ':'); /* Set up the semaphore set. 4 == READ, 2 == ALTER */ semid = semget(ipckey, 1, 0666 | IPC_CREAT); if (semid \u003c 0) { printf(\"Error - %s\\n\", strerror(errno)); _exit(1); } /* These never change so leave them outside the loop */ sem[0].sem_num = 0; sem[1].sem_num = 0; sem[0].sem_flg = SEM_UNDO; /* Release semaphore on exit */ sem[1].sem_flg = SEM_UNDO; /* Release semaphore on exit */ int loop = 10; while(loop--) { /* loop forever */ printf(\"[%s] Waiting for the semaphore to be released\\n\", argv[1]); /* Set up two semaphore operations */ sem[0].sem_op = 0; /* Wait for zero */ sem[1].sem_op = 1; /* Add 1 to lock it*/ semop(semid, sem, 2); printf(\"[%s] I have the semaphore\\n\", argv[1]); sleep(rand() % 3); /* Critical section, sleep for 0-2 seconds */ sem[0].sem_op = -1; /* Decrement to unlock */ semop(semid, sem, 1); printf(\"[%s] Released semaphore\\n\", argv[1]); sleep(rand() % 3); /* Sleep 0-2 seconds */ } } 执行程序： ./daemon a \u0026 ./daemon b \u0026 ./daemon c \u0026 执行结果： [a] I have the semaphore [b] Waiting for the semaphore to be released [c] Waiting for the semaphore to be released [a] Released semaphore [b] I have the semaphore [b] Released semaphore [c] I have the semaphore [a] Waiting for the semaphore to be released [b] Waiting for the semaphore to be released [c] Released semaphore [a] I have the semaphore [a] Released semaphore [b] I have the semaphore [b] Released semaphore [b] Waiting for the semaphore to be released [b] I have the semaphore [c] Waiting for the semaphore to be released [a] Waiting for the semaphore to be released [b] Released semaphore ","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/:3:1","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"同步 生产者： #include \u003csys/types.h\u003e #include \u003csys/sem.h\u003e #include \u003csys/ipc.h\u003e #include \u003cstring.h\u003e #include \u003cerrno.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e int main (void) { key_t ipckey; int semid; struct sembuf sem[2]; ipckey = ftok(\"/tmp/test\", ':'); semid = semget(ipckey, 1, 0600|IPC_CREAT|IPC_EXCL); if (semid \u003c 0) { printf(\"Sem Create Error - %s\\n\", strerror(errno)); exit(1); } sem[0].sem_num = 0; sem[1].sem_num = 0; sem[0].sem_flg = SEM_UNDO; sem[1].sem_flg = SEM_UNDO; int loop = 10; while(loop--) { sem[0].sem_op = 0; sem[1].sem_op = 1; semop(semid, sem, 2); printf(\"I produce\\n\"); sleep(3); } } 消费者： #include \u003csys/types.h\u003e #include \u003csys/sem.h\u003e #include \u003csys/ipc.h\u003e #include \u003cstring.h\u003e #include \u003cerrno.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e int main (void) { key_t ipckey; int semid; struct sembuf sem[1]; ipckey = ftok(\"/tmp/test\", ':'); semid = semget(ipckey, 1, 0600|IPC_CREAT); if (semid \u003c 0) { printf(\"Sem Create Error - %s\\n\", strerror(errno)); exit(1); } sem[0].sem_num = 0; sem[0].sem_flg = SEM_UNDO; int loop = 10; while(loop--) { sem[0].sem_op = -1; semop(semid, sem, 1); printf(\"I consume\\n\"); sleep(0); } if (semctl(semid, 0, IPC_RMID) == -1) { printf(\"Sem Delete Error - %s\\n\", strerror(errno)); exit(1); } printf(\"Sem Delete!\\n\"); } 执行程序： ./produce \u0026 ./consume \u0026 执行结果： I produce I consume I produce I consume I produce I consume 深入分析Linux内核源代码,7.3.1 ↩︎ 使用 UNIX System V IPC 机制共享应用程序数据 ↩︎ 深入分析Linux内核源代码,7.3.1.2,P279 ↩︎ REDHAT AS4内核调优之kernel.sem的设置(原创) ↩︎ 深入分析Linux内核源代码,表7.2,P282 ↩︎ 使用 UNIX System V IPC 机制共享应用程序数据,清单5 ↩︎ ","date":"2016-09-01","objectID":"/article/2016/09/01/linux-ipc-semaphore/:3:2","tags":["ipc","sysv"],"title":"信号量","uri":"/article/2016/09/01/linux-ipc-semaphore/"},{"categories":["system"],"content":"消息队列","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"为了提供与其他系统的兼容性，Linux 也支持 3 种 system V 的进程间通信机制：消息、信号量（semaphores）和共享内存，Linux 对这些机制的实施大同小异。我们把信号量、消息和共享内存统称 System V IPC 的对象，每一个对象都具有同样类型的接口，即系统调用。就像每个文件都有一个打开文件号一样，每个对象也都有唯一的识别号，进程可以通过系统调用传递的识别号来存取这些对象，与文件的存取一样，对这些对象的存取也要验证存取权限，System V IPC 可以通过系统调用对对象的创建者设置这些对象的存取权限。1 一个或多个进程可向消息队列写入消息，而一个或多个进程可从消息队列中读取消息，这种进程间通信机制通常使用在客户/服务器模型中，客户向服务器发送请求消息，服务器读取消息并执行相应请求。在许多微内核结构的操作系统中，内核和各组件之间的基本通信方式就是消息队列。2 注： IPC: Inter-Process Communication（进程间通信） ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:0:0","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"流程 一般流程3如下： 通过 ftok 获得确定的 IPC Key 使用 msgget 获得用于消息队列的特定 IPC ID 使用 msgsnd/msgrcv 收发消息 使用 msgctl 移除队列 ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:1:0","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"函数 常用函数4如下： ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:2:0","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"ftok 将路径文件名（存在且可访问）和一个 8bit 标识符转换成 System V IPC 键值。 #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e key_t ftok(const char *pathname, int proj_id) pathname：文件名，必须存在 proj_id：仅 8bit 有效，不可为零 return：-1，发生错误，可通过 errno 查看；其他返回表示得到的键值 注： 只要 pathname 和 proj_id 一致则返回的键值就一直，因此两个进程可以通过此函数获得同一个键值。 ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:2:1","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"msgget 建立一个消息队列。 #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/msg.h\u003e int msgget(key_t key, int msgflg) key：ftok 中返回的键值 msgflg：使用 | 连接 权限：可使用 0666 等表示，也可使用 open 中 mode 宏 IPC_CREAT：若不存在则创建 IPC_EXCL：若存在则返回错误（和 IPC_CREAT 一起使用） return：-1，发生错误，可通过 errno 查看；非负数，消息队列 ID 注： 系统中的消息队列可通过 ipcs -q 查看。 ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:2:2","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"msgctl 对消息队列的控制，查询、设置、删除。 #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/msg.h\u003e int msgctl(int msqid, int cmd, struct msqid_ds *buf) msqid：msgget 得到 ID cmd：常用如下 IPC_STAT：从内核获得消息队列的信息到 buf 中 IPC_SET：通过 buf 修改内核中该消息的一些信息 IPC_RMID：从内核移除该消息 buf：消息队列的相关信息 return：-1，发生错误，可通过 errno 查看 注： 系统中已存在的消息也可通过 ipcrm -q/Q 来删除。 ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:2:3","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"msgsnd/msgrcv 发送/接收消息到队列。 #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/msg.h\u003e int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg) ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) msqid：msgget 得到 ID msgp：形式如下 struct msgbuf { long mtype; /* message type, must be \u003e 0 */ char mtext[1]; /* message data */ }; mtype 必须包含，data 部分可以是自定义的数据结构（总长度不能超过 8192 字节）5。 msgsz：消息长度 msgflg： 0：忽略 IPC_NOWAIT：消息队列满则返回程序继续执行，否则阻塞 0：忽略 IPC_NOWAIT：如果消息队列为空则程序继续执行，否则阻塞 MSG_EXCEPT：msgtyp \u003e 0 时作用，取不等于 MSG_NOERROR：如果消息大于 msgsz 自动截断丢弃，否则不会被取出 msgtyp： 等于 0：取出队列中最早的消息 大于 0：取出消息中最早 mtype 等于此值的消息 小于 0：取出消息中最早 mtype 小于等于此值绝对值的消息 return：-1，发生错误，可通过 errno 查看 ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:2:4","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"实例 服务器/客户端例子6 ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:3:0","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"server #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cerrno.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/msg.h\u003e #include \u003csignal.h\u003e #define MSG_FILE \"server.c\" #define BUFFER 255 #define PERM S_IRUSR|S_IWUSR int msgid; static void clean_exit(int sig) { // 从内核中移除消息 if (msgctl(msgid, IPC_RMID, NULL) == -1) { fprintf(stderr,\"Remove Message Error：%s\\a\\n\",strerror(errno)); exit(1); } exit(sig); } struct msgtype { long mtype; char buffer[BUFFER+1]; }; int main() { signal(SIGINT, clean_exit); struct msgtype msg; key_t key; // 获得消息键 if((key=ftok(MSG_FILE,'a'))==-1) { fprintf(stderr,\"Creat Key Error：%s\\a\\n\",strerror(errno)); exit(1); } // 创建消息 if((msgid=msgget(key,PERM|IPC_CREAT|IPC_EXCL))==-1) { fprintf(stderr,\"Creat Message Error：%s\\a\\n\",strerror(errno)); exit(1); } while(1) { msgrcv(msgid,\u0026msg,sizeof(struct msgtype),1,0); fprintf(stderr,\"Server Receive：%s\\n\",msg.buffer); msg.mtype=2; msgsnd(msgid,\u0026msg,sizeof(struct msgtype),0); } exit(0); } ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:3:1","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["system"],"content":"client #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cerrno.h\u003e #include \u003csys/types.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/msg.h\u003e #include \u003csys/stat.h\u003e #define MSG_FILE \"../server/server.c\" #define BUFFER 255 #define PERM S_IRUSR|S_IWUSR struct msgtype { long mtype; char buffer[BUFFER+1]; }; int main(int argc,char **argv) { struct msgtype msg; key_t key; int msgid; if(argc!=2) { fprintf(stderr,\"Usage：%s string\\n\\a\",argv[0]); exit(1); } if((key=ftok(MSG_FILE,'a'))==-1) { fprintf(stderr,\"Creat Key Error：%s\\a\\n\",strerror(errno)); exit(1); } if((msgid=msgget(key,PERM))==-1) { fprintf(stderr,\"Creat Message Error：%s\\a\\n\",strerror(errno)); exit(1); } msg.mtype=1; strncpy(msg.buffer,argv[1],BUFFER); msgsnd(msgid,\u0026msg,sizeof(struct msgtype),0); memset(\u0026msg,'\\0',sizeof(struct msgtype)); msgrcv(msgid,\u0026msg,sizeof(struct msgtype),2,0); fprintf(stderr,\"Client receive：%s\\n\",msg.buffer); exit(0); } 深入分析Linux内核源代码,7.3 ↩︎ 深入分析Linux内核源代码,7.3.2 ↩︎ 使用 UNIX System V IPC 机制共享应用程序数据 ↩︎ linux man 手册 ↩︎ 深入分析Linux内核源代码,7.3.2,P284 ↩︎ linux c学习笔记—-消息队列（ftok,msgget，msgsnd，msgrcv，msgctl） ↩︎ ","date":"2016-08-31","objectID":"/article/2016/08/31/linux-ipc-sysv-message-queue/:3:2","tags":["ipc","sysv"],"title":"消息队列","uri":"/article/2016/08/31/linux-ipc-sysv-message-queue/"},{"categories":["tools"],"content":"博客使用 hexo 搭建","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"本博客就是使用 Hexo 生成的，但是我平常使用的都是 Windows 系统，使用 Hexo 需要安装不少软件。 而我又不想安装很多软件，所以研究着怎么用虚拟机和 Windows 配合使用 Hexo。 下面就是具体的方法。 ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:0:0","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"Hexo 安装 官方文档 ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:1:0","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"Node.js 在官方下载相应版本的 Node.js 安装包， 我使用 CentOS，下载了 Linux Binaries x64，是已经编译好的二进制文件，配置一下环境变量即可。 tar -xvJf node-v6.3.1-linux-x64.tar.xz mv node-v6.3.1-linux-x64 /usr/local/soft vi ~/.bash_profile 添加 PATH 路径 export NODEJS_HOME=/usr/local/soft/node-v6.3.1-linux-x64 export PATH=$PATH:$NODEJS_HOME/bin 保存退出 source ~/.bash_profile node -v ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:1:1","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"Git 可直接使用 yum 安装 yum install git ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:1:2","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"Hexo npm install -g hexo-cli 等待几秒钟，安装完成后可发现在 NODEJS_HOME/bin 路径中增加了 hexo 的二进制文件。 ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:1:3","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"Linux 虚拟机设置共享文件夹 参考 ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:2:0","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"安装 samba yum install samba samba-winbind​ ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:2:1","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"配置 samba mv /etc/samba/smb.conf /etc/samba/smb.conf.bak vi /etc/samba/smb.conf 写入文件 [global] workgroup = WORKGROUP server string = Samba Server %v netbios name = centos interfaces = eth0 ## 监听网卡 security = user passdb backend = tdbsam guest account = nobody [share] public = no path = /home/user/share browsable =yes writable = yes ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:2:2","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"配置防火墙 CentOS 7 使用的是 firewall 防火墙，我首先把网络设置到 home 类型，然后添加了 samba 服务。 firewall-cmd --zone=home --add-service=samba firewall-cmd --permanent --zone=home --add-service=samba ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:2:3","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"开启 samba systemctl enable smb.service systemctl restart smb.service 设置密码，使用 root，方便更改文件 smbpasswd -a root 可使用以下命令查看是否成功设置 smbpasswd -e 配置共享文件夹 mkdir -p /home/user/share cd /home/user chmod 755 share/ chcon -t samba_share_t share/ 在 Windows 资源管理器中输入虚拟机地址 \\\\192.168.61.128，可看到共享的文件夹 share。 ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:2:4","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"新建 Hexo hexo init \u003cfolder\u003e cd \u003cfolder\u003e npm install ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:3:0","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"恢复 Hexo 只要保存 package.json 文件，在文件夹内执行以下命令即可恢复。 npm install ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:4:0","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"主题配置 如果安装了其他主题，请主动安装恢复，否则调试会出现错误（WARN No layout: index.html）。 ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:5:0","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"Blog 调试部署 参考 ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:6:0","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"调试 本地查看 hexo server // 默认 localhost:4000 hexo server -i 192.168.1.2 -p 5000 // 修改 IP 及 Port ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:6:1","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"部署 安装：hexo-deployer-git npm install hexo-deployer-git --save 配置：_config.yml ## Deployment ### Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@xxx.git branch: xxx Git 设置：用户名邮箱以及 ssh key 相应配置 发布：hexo generate --deploy ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:6:2","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"CICD github 自从被微软收购了，真是不差钱，有了 Actions 直接线上编辑文章自动部署，本地也不需要搭什么环境了。^-^ ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:7:0","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"leancloud.memo 站点中使用 leancloud 中统计，但是免费版 api 调用有限制，经常会出现 429 错误。 那么就需要保存更新 memo 本地数据库文件： prepare: name: Prepare runs-on: ubuntu-18.04 steps: - name: Checkout uses: actions/checkout@v2 with: repository: {repository} ## 站点文件位置 - name: Setup Node uses: actions/setup-node@v1 with: node-version: '12.x' - name: Upload artifact uses: actions/upload-artifact@v2 with: name: leancloud path: leancloud.memo ## 保存上次文章路径本地数据库 deploy: name: Deploy needs: prepare runs-on: ubuntu-18.04 steps: - name: Checkout uses: actions/checkout@v1 with: submodules: true - name: Download artifact uses: actions/download-artifact@v2 with: name: leancloud path: source ## 保存本地 这里遇到一个问题，deploy 时插件更新 memo 文件在拷贝 public 文件夹之后，所以导致新的 memo 文件不能传到站点上，目前简单的解决办法就是部署两次。 ","date":"2016-07-28","objectID":"/article/2016/07/28/hexo/:7:1","tags":["web","centos"],"title":"Hexo Blog","uri":"/article/2016/07/28/hexo/"},{"categories":["tools"],"content":"Sublime Text","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"之前一直用 Notepad++ ，后来发现了 Sublime Text 被界面和风格吸引了，而且支持各种 markdown 插件，来试试好不好用，如果上手了就可以抛弃 Notepad 了。 以下是网上各种资料的整理以便快速搭建顺手的环境。 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:0:0","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"安装 官方网站：http://www.sublimetext.com/ 根据平台下载相应版本并安装 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:1:0","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"Package Control 这个应该算是必须安装的吧，一键管理所有插件有木有。 安装方法可见官网：https://packagecontrol.io/installation View \u003e Show Console 在命令行输入命令，注意是最下面的一行，不是在文件里面输入（开始犯的低级错误） 重启软件 使用方法 Ctrl + Shift + P 调出 Package Control， 安装插件，输入 install，选择 Install Package，然后可以搜索插件了， 卸载插件，输入 remove，选择 Remove Package ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:2:0","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"语言包 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:3:0","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"ConvertToUTF8 将文件编码转换为 UTF8 插件 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:3:1","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"ChineseLocalization 菜单栏汉化包 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:3:2","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"基本教程 Sublime Text 全程指南 Sublime Text：学习资源篇 显示制表符和空格 用户设置中添加：\"draw_white_space\": \"all\" 中文输入法问题 输入框无法跟随，安装 IMESupport 插件即可 快速跳转 Ctrl + R 删除空行 Ctrl+H 进入替换模式，然后 Alt+R 或者点击左边第一行一个的正则表达式，变得更灰表示使用正则模式。第一行查找部分输入^\\n 替换部分为空，再 Replace All。这样就可以把所有空行都删掉。 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:4:0","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"其他插件 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:5:0","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"Compare Side-By-Side 简易比较工具，标签上右键选择 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:5:1","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"HexViewer 连这个都有，分析十六进制的利器啊，需要使用 Package Control 开启 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:5:2","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"Markdown MarkDown Editing 基本编辑 OmniMarkupPreviwer 实时渲染到网页 可以配置基本扩展：首选项 -\u003e Package Setttings -\u003e OmniMarkupPreviwer -\u003e Settings User 配置如下： { \"mathjax_enabled\": true, \"renderer_options-MarkdownRenderer\": { \"extensions\": [ \"tables\", \"fenced_code\", \"codehilite\", \"toc\", \"nl2br\", \"footnotes\", \"strikeout\" ] } } Markdown Extended \u0026 Monokai extended 文中代码高亮 使用： Markdown Extended：View -\u003e Syntax -\u003e Open all with current extension as… -\u003e Markdown Extended Monokai extended：Preferences\u003eColor Scheme\u003eMonokai Extended TableEditor 自动对齐表格 Markdown TOC 自动插入目录，可配置目录级数，和自动超链接，一般如下设置即可。 depth=3 autolink=true bracket=round Snippets 是 Sublime 自带功能，工具 -\u003e 代码段 能查看现在支持的复用代码段。 创建：工具 -\u003e 新代码段 \u003csnippet\u003e \u003ccontent\u003e\u003c![CDATA[ 你需要插入的代码片段${1:name} ]]\u003e\u003c/content\u003e \u003c!-- 可选：快捷键，利用Tab自动补全代码的功能 --\u003e \u003ctabTrigger\u003exyzzy\u003c/tabTrigger\u003e \u003c!-- 可选：使用范围，不填写代表对所有文件有效。附：source.css和test.html分别对应不同文件。 --\u003e \u003cscope\u003esource.python\u003c/scope\u003e \u003c!-- 可选：在snippet菜单中的显示说明（支持中文）。如果不定义，菜单则显示当前文件的文件名。 --\u003e \u003cdescription\u003eMy Fancy Snippet\u003c/description\u003e \u003c/snippet\u003e ${1:name} 表示代码插入后，光标所停留的位置，可同时插入多个。其中 :name 为自定义参数（可选）。 ${2} 表示代码插入后，按 Tab 键，光标会根据顺序跳转到相应位置（以此类推）。 保存在 Data\\Packages\\User 下，后缀名为 .sublime-snippet。 使用方法：name Tab 键 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:5:3","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"CoolFormat 代码自动格式化（不能格式化 golang） 需要格式化的代码保存为相应后缀文件，一般用来整理笔记中粘贴的代码，可节省一部分时间。 相应设置在 CoolFormatConfig.cfconfig 文件中： C++=\"\"-A10-p-N-Y-H-U-xe-k3-j\"\" ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:5:4","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"附录 ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:6:0","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"Settings 显示文件类型： \"show_encoding\": true, \"show_line_endings\": true, 设置默认换行符： \"default_line_ending\": \"unix\" 增强显示： \"highlight_line\": true, \"highlight_modified_tabs\": true, 自动删除行末空格： \"trim_trailing_white_space_on_save\": true 设置主题： \"theme\": \"Lanzhou.sublime-theme\" 设置快捷键： [ { \"keys\": [\"ctrl+k\"], \"command\": \"toggle_side_bar\" }, //隐藏显示文件目录 { \"keys\": [\"alt+s\"], \"command\": \"toggle_menu\" }, //隐藏显示菜单栏 ] ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:6:1","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"Snippet mdl 插入链接 \u003csnippet\u003e \u003ccontent\u003e\u003c![CDATA[ [${1:Display_Text}](${2:http://example.com/} ${3:\"$2\"}) ]]\u003e\u003c/content\u003e \u003ctabTrigger\u003emdl\u003c/tabTrigger\u003e \u003cscope\u003etext.html.markdown.multimarkdown, text.html.markdown\u003c/scope\u003e \u003cdescription\u003eInsert Link\u003c/description\u003e \u003c/snippet\u003e mdll 插入参考式链接 \u003csnippet\u003e \u003ccontent\u003e\u003c![CDATA[ [${1:Display_Text}][${2:id}]$5 [$2]:${3:http://example.com/} ${4:\"$3\"} ]]\u003e\u003c/content\u003e \u003ctabTrigger\u003emdll\u003c/tabTrigger\u003e \u003cscope\u003etext.html.markdown.multimarkdown, text.html.markdown\u003c/scope\u003e \u003cdescription\u003eLink Anchor\u003c/description\u003e \u003c/snippet\u003e mdi 插入图片 \u003csnippet\u003e \u003ccontent\u003e\u003c![CDATA[ ![${1:Some_Text}](${2:url_to_image} ${3:\"$1\"}) ]]\u003e\u003c/content\u003e \u003ctabTrigger\u003emdi\u003c/tabTrigger\u003e \u003cscope\u003etext.html.markdown.multimarkdown, text.html.markdown\u003c/scope\u003e \u003cdescription\u003eInsert Image\u003c/description\u003e \u003c/snippet\u003e mdn 插入注脚 \u003csnippet\u003e \u003ccontent\u003e\u003c![CDATA[ [^${1:Footnote}]$3 [^$1]:${2:Footnote_Text} ]]\u003e\u003c/content\u003e \u003ctabTrigger\u003emdn\u003c/tabTrigger\u003e \u003cscope\u003etext.html.markdown.multimarkdown, text.html.markdown\u003c/scope\u003e \u003cdescription\u003eInsert Footnote\u003c/description\u003e \u003c/snippet\u003e ","date":"2016-01-23","objectID":"/article/2016/01/23/sublime/:6:2","tags":["ide"],"title":"Sublime Text","uri":"/article/2016/01/23/sublime/"},{"categories":["tools"],"content":"StarUML 使用","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"前些日子整理文档，需要补充程序结构流程图，一直没有想到怎么样能够清晰直观描述清楚现在的解决方法，直到我知道了 UML 语言。最早对于 UML 的了解也只是停留在一本书上，他们开发使用 UML 分解任务，做成任务卡片，好分析开发时间。 现在才发现原来 UML 很强大。 StarUML 是个开源软件，画基本的 UML 图是基本够用了，而且可以保存工程以便后续修改，还可以自动导入现有工程进行分析，感觉用来辅助编写文档再合适不过了。 ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:0:0","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"下载安装 网址：http://staruml.io/ 安装选择评估就行 ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:1:0","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"界面说明 基本界面可以被分为 6 块： (1) 菜单栏 (2) 显示你已经打开的所有设计图 (3) 是绘图模块，鼠标选中，直接点到 (4) 上就可以放到画布上了 (4) 画布 (5) 是工程，右键可以添加删除设计图和模块 (6) 绘图模块属性，可以重命名和修改属性 软件自带工程：C:\\Program Files (x86)\\StarUML\\samples 下 ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:2:0","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"结构图 ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:3:0","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"继承 class B extends A 使用 Generalization ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:3:1","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"实现 class A extends I 使用 Interface Realization ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:3:2","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"依赖 import A; 使用 Dependency，在 stereotype 属性中可以填写一些说明，比如 use，create 等。 ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:3:3","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"连接 从上到下依次关系越来越紧密，分别是 Directed Association，Aggregation 和 Composition。 参考：http://developer.51cto.com/art/201007/209616.htm ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:3:4","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"时序图 水平方向列出所有对象，垂直方向从上到下表示时间增长。 各对象之间通过消息传递信息，消息包括同步和异步之分。 使用 CombinedFragment 可以表示逻辑，包括选择，循环，并行等。 参考：http://m.blog.csdn.net/blog/pashanhuxp/41982285 ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:4:0","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"快捷键 ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:5:0","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"导入工程 安装相应语言的工具，Tools-\u003eExtension Manager-\u003eJava-\u003einstall 安装成功后 Tools 下就会多出你刚刚安装语言的选项。 Tools-\u003eJava-\u003eConfigure 配置载入或生成代码的规则。 载入工程 Tools-\u003eJava-\u003eReverse Code 选择你的工程，StarUML 会自动分析。 ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:5:1","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"格式 Format-\u003e… 连线样式：斜线「Ctrl+B」，直线「Ctrl+L」 文字颜色：Font-\u003e… ","date":"2015-10-13","objectID":"/article/2015/10/13/staruml/:5:2","tags":["uml"],"title":"StarUML","uri":"/article/2015/10/13/staruml/"},{"categories":["tools"],"content":"iperf 测试带宽","date":"2015-06-28","objectID":"/article/2015/06/28/iperf/","tags":["iperf","test"],"title":"iperf 测试带宽","uri":"/article/2015/06/28/iperf/"},{"categories":["tools"],"content":"之前被要求测试网卡带宽能力，发现了 iperf 这个工具，记录下来防止遗忘。 iperf 是个开源跨平台测试带宽工具，windows、linux、macOS …… 都支持，安装也挺方便。 ","date":"2015-06-28","objectID":"/article/2015/06/28/iperf/:0:0","tags":["iperf","test"],"title":"iperf 测试带宽","uri":"/article/2015/06/28/iperf/"},{"categories":["tools"],"content":"安装 地址：https://iperf.fr/ ","date":"2015-06-28","objectID":"/article/2015/06/28/iperf/:1:0","tags":["iperf","test"],"title":"iperf 测试带宽","uri":"/article/2015/06/28/iperf/"},{"categories":["tools"],"content":"测试 参看：https://www.52os.net/articles/iperf-check-bandwidth.html 无论是 tcp 还是 udp 方式测试，都要一端运行服务器模式，另一端运行客户端模式，另外如果开了 iptables，要打开 tcp 5001 端口，当然也可以指定端口。 ","date":"2015-06-28","objectID":"/article/2015/06/28/iperf/:2:0","tags":["iperf","test"],"title":"iperf 测试带宽","uri":"/article/2015/06/28/iperf/"},{"categories":["tools"],"content":"tcp 方式 服务器端： iperf –s 客户端： 单线程 iperf -c SERVERIP -t 60 -i 1 多线程 iperf -c SERVERIP -t 60 -i 1 -P 5 ","date":"2015-06-28","objectID":"/article/2015/06/28/iperf/:2:1","tags":["iperf","test"],"title":"iperf 测试带宽","uri":"/article/2015/06/28/iperf/"},{"categories":["tools"],"content":"udp 方式 服务器端： iperf -u –s 客户端： iperf -c SERVERIP -t 60 -i 1 -b 100M ","date":"2015-06-28","objectID":"/article/2015/06/28/iperf/:2:2","tags":["iperf","test"],"title":"iperf 测试带宽","uri":"/article/2015/06/28/iperf/"},{"categories":["tools"],"content":"遇到的问题 ","date":"2015-06-28","objectID":"/article/2015/06/28/iperf/:3:0","tags":["iperf","test"],"title":"iperf 测试带宽","uri":"/article/2015/06/28/iperf/"},{"categories":["tools"],"content":"防火墙要关闭 我使用 win8 和 centos 测试，开始 ping 不通 win8，后来发现 win8 的防火墙没关，关上就好了…… 后来又发现 win8 只能做服务端，如果作为客户端，centos 就收不到数据，才发现 centos 也有默认的防火墙…… 关闭防火墙服务 systemctl stop firewalld 关闭后 centos 就可以作为服务端了 ","date":"2015-06-28","objectID":"/article/2015/06/28/iperf/:3:1","tags":["iperf","test"],"title":"iperf 测试带宽","uri":"/article/2015/06/28/iperf/"},{"categories":["tools"],"content":"带宽测不满 我测试两边都是千兆网卡，第一次测试大概 900Mbps 多，但是后来就变为 95Mbps，这是怎么回事？ 开始以为是 iperf 版本问题，换了也还是不行，后来发现原来是网络有自动协商功能，而我查看本地连接自动协商结果为 100Mbps，这样带宽当然不会超过 100Mbps 了，然后我修改自动协商为固定 1000Mbps 双工 win8设置：网络连接-\u003e适配器-\u003e属性-\u003e网卡配置-\u003e高级-\u003e速度和双工-\u003e1.0Gbps cenos 设置： 查看详细信息 ethtool eno1 设置禁用自动协商设定固定速度和工作方式 ethtool -s ethx autoneg off speed 1000 duplex full 但是可悲的是以上设置完成，网络就连不上了链路层就探测不到了，不知道是不是 win8 和 cenos 不兼容？ ","date":"2015-06-28","objectID":"/article/2015/06/28/iperf/:3:2","tags":["iperf","test"],"title":"iperf 测试带宽","uri":"/article/2015/06/28/iperf/"},{"categories":["system"],"content":"最近使用了 CentOS 发现比 Ubuntu 更简洁，有些爱上 CentOS 了。 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:0:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"准备安装镜像文件 官方有三个版本：DVD、Everything 和 Minimal， 我选择安装的是 Minimal - CentOS-7.0-1406-x86_64-Minimal.iso。 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:1:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"VM11 下安装 点击创建新的虚拟机，选择「典型（推荐）」 选择「安装光盘映像文件」，选择上面准备好的文件路径 设置用户名和密码（需要牢记这是安装完程序进入后的默认 root 密码） 选择安装位置，一般 20GB 空间够了，多文件拆分保存 选择完成，等待虚拟机安装就行啦 我在安装当中出现了「二进制转换与此平台上的长模式不兼容」的问题，安装被中断 这时需要重启进入 BOIS（我是开机按住 F2 键），在 BOIS 中找到 Intel virtual technology 设置为 Enable 即可，再次开机打开虚拟机就能正常使用了 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:2:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"配置网络 输入：ip addr，显示网络并未连接 查看 虚拟机-\u003e设置-\u003e网络适配器 选择连接模式为 NAT模式 终端打开 /etc/sysconfig/network-script/ifcfg-eno16777736 修改 ONBOOT=yes 输入 service network restart 重启网络服务，再次检查 ip，以及 ping ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:3:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"更新及安装软件 yum install kernel-devel yum -y update yum install vim //强大的Vi编辑器 yum install wget //从网络上自动下载文件的工具 yum install gcc //一套由GNU工程开发的支持多种编程语言的编译器 yum install cpp yum install gcc-c++ yum install make //makefile yum install gdb //调试工具 yum inatall perl //后面安装MVwareTools必装软件 yum install net-tools //ifconfig命令,MVwareTools也需要使用 yum groupinstall \"Development Tools\" 查询本地是否安装某个软件 输入： rpm –qa xxx 返回：版本号 or 无 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:4:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"修改默认分辨率 查看：http://www.centoscn.com/CentOS/config/2014/1031/4029.html 修改文件 /boot/grub2/grub.cfg，找到 linux16 /vmlinuz-3.10.0-123.el7.x86_64 root=UUID=881ac4e6-4a55-47b1-b864-555de7051763 ro rd.lvm.lv=centos/swap vconsole.font=latarcyrheb-sun16 rd.lvm.lv=centos/root crashkernel=auto vconsole.keymap=us rhgb quiet LANG=en_US.UTF-8 在后面添加 vga=0x???（问号代表分辨率代码），在这里贴一张对应表，方便查看 修改后如下： 然后修改运行级别，打开 /etc/inittab 在后面添加 ## ln -sf /lib/systemd/system/runlevel?.target /etc/systemd/system/default.target 保存后，快来重启试试吧！ ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:5:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"安装 VMwareTools 点击 虚拟机-\u003e安装VMware Tools 加载镜像 mkdir /mnt/cdrom mount /dev/cdrom /mnt/cdrom #挂载设备 cd /mnt/cdrom cp vmware-tools-xxxxxx.tar.gz /root umount /mnt/cdrom #关闭设备 cd /root tar zxvf vmware-tools-xxxxxx.tar.gz #解压文件 安装 vmware-tools cd vmware-tools-distrib #进入文件目录 ./vmware-install.pl #安装 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:6:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"配置共享文件夹 点击「设置」，添加共享文件夹 在终端下 /mnt/hgfs/ 下可以看到刚才添加的文件夹 现在可以无缝连接 windows 和 linux 世界了 我在系统 update 后曾经找不到共享文件夹了，后来上网查找发现需要重新配置 Tools 运行 /usr/bin/vmware-config-tools.pl 即可 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:7:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"HelloWorld 让我们来编译运行一下程序 在 windows 下编写一个 HelloWorl 原文件，到虚拟机中编译运行，快看 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:8:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"man 手册补全 最近使用中发现 man 总是查找不到命令，后来才知道貌似 man 手册不全，需要自己下载 yum install man-pages –y 还可以安装一个中文手册 中文手册下载地址：http://manpages-zh.googlecode.com/files/manpages-zh-1.5.1.tar.gz 解压安装： tar zxvf manpages-zh-1.5.1.tar.gz cd manpages-zh-1.5.1 ./configure --disable-zhtw make \u0026\u0026 make install 设置环境变量： vim ~/.bash_profile alias cman='man -M /usr/local/share/man/zh_CN' 使环境变量生效 source ~/.bash_profile 然后就可以使用 cman 查询中文版的手册了 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:9:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"使用 ssh 登录 在虚拟机中使用 centos 唯一不方便的就是鼠标要在虚拟机和本机中切换，而且虚拟机中出现问题，也不能复制，后来发现 ssh 是可以在本机上登录的。 在虚拟机中输入 ifconfig 获得 ip 地址 在本机上打开 ssh 登录上面的地址就 ok 了 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:10:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"使用 ssh 传输文件 ssh 是可以在本机和远程主机中传输文件的 使用 sz rz 命令 首先需要安装 yum -y install lrzsz rz 传输文件到 ssh sz 接收 ssh 的文件 ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:11:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"},{"categories":["system"],"content":"开发编译和 kernel 相关 需要安装配置一些，原文。 检查 Linux Version uname -r 检查 kernel 先关的包 是否安装，安装了是否与当前系统版本匹配 rpm -qa | grep kernel 至少应该有 kernel，kernel-devel，kernel-tools 以及 kernel-headers 几个包有 然后检查软连接是否有错误，如果 build 和 source 是红色标示不对，绿色就对了 cd /lib/modules/'上面uname -r的结果'/ ls 如果不对 ，删除 build，重新建立一下软连接 rm -rf build ln -s /usr/src/kernels/xxx /lib/modules/xxx/build ","date":"2015-05-23","objectID":"/article/2015/05/23/centos-7-mini-install-and-configuration/:12:0","tags":["centos","vm"],"title":"VM11下 CentOS 7 mini 安装及配置","uri":"/article/2015/05/23/centos-7-mini-install-and-configuration/"}]